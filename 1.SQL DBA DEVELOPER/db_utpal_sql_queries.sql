--QUERY TO CREATE DATABASE
CREATE DATABASE [DB_UTPAL]

--QUERY TO CREATE TABLE
USE [DB_UTPAL]
CREATE TABLE TBL_EMPLOY_MASTER (EMPID INT, EMPNAME VARCHAR(30), EMPADDRESS NVARCHAR(100), 
								GENDER CHAR(1), AGE INT, MOBILE_NUMBER BIGINT, 
								DESIGNATION VARCHAR(20), DATE_OF_JOIN DATE, ACTIVE BIT)
--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN VARCHAR AND CHAR DATA TYPES
--CHAR DATA TYPE IS USED FOR THE STORING THE FIXED LENGTH OF CHARACTERS 
--AND VARCHAR IS USED FOR STORING THE VARIABLE LENGTH OF CHARACTERS
--101
--WHAT IS THE DIFFERENCE BETWEEN VARCHAR AND NVARCHAR DATA TYPES
--BOTH VARCHAR AND NVARCHAR ALLOWS TO STORE STRING VALUES, NUMERIC VALUES AND SPECIAL CHARACTERS 
--BUT INSIDE NVARCHAR COLUMNS WE CAN STORE SOME EXTRA SPECIAL CHARACTERS AND DIFFERENT LANGUAGES DATA ALSO 
--AND IF WE DECLARE VARCHAR WITH 30 LENGTH, THEN SQL SERVER WILL ALLOCATE 30 BITS OF MEMORY  
--AND IF WE DECLARE NVARCHAR WITH 30 LENGTH, THEN SQL SERVER WILL ALLOCATE 60 BITS (30*2) OF MEMORY

--INSERTING THE DATA INTO THE TABLE
INSERT INTO TBL_EMPLOY_MASTER VALUES (1,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
	
INSERT INTO TBL_EMPLOY_MASTER VALUES (2,'RAMESH','HYDERABAD,K.R.PURAM','M',33,34534,'TEAM LEAD','12/24/2017',1)
, (3,'SURESH','CHENNAI,K.R.PURAM','M',32,3453434543,'PROJECT LEAD','12/25/2017',1)
, (4,'VARUN','MUMBAI,K.R.PURAM','M',31,256565656,'DELIVERY LEAD','12/26/2017',1)

INSERT INTO TBL_EMPLOY_MASTER VALUES (5,'SUMATHI',NULL,'F',NULL,NULL,NULL,NULL,NULL)
INSERT INTO TBL_EMPLOY_MASTER VALUES (6,'MANASWINI','','F','','','','','')
INSERT INTO TBL_EMPLOY_MASTER (EMPID,EMPNAME,GENDER) VALUES (7,'MOHAN','M')

SELECT * FROM TBL_EMPLOY_MASTER

--SELECT * FROM EMP_ADDRESS
--SELECT * FROM EMP_DATA_CHENNAI
--SELECT * FROM TBL_CHENNAI_EMPLOYS

--SP_RENAME 'EMP_ADDRESS$','TBL_EMPLOYS_ADDRESS'

--SELECT * FROM TBL_EMPLOYS_ADDRESS

--SP_RENAME 'TBL_EMPLOYS_ADDRESS.PHONENUMBER', 'MOBILE_NO','COLUMN'
b
SELECT * FROM [dbo].[tbl_empl_master]

--TRANSFERRING THE DATA INTO A NEW TABLE
SELECT * INTO TBL_EMPLS_BANK_DETAILS 
FROM [dbo].[tbl_empls_bank_details]

SELECT * FROM TBL_EMPLS_BANK_DETAILS

--HOW TO TRANSFER THE DATA INTO A ALREADY EXISTING TABLE
INSERT INTO TBL_EMPLS_BANK_DETAILS
SELECT * FROM DB_MOHAN.[dbo].[tbl_empls_bank_details]

--HOW TO MODIFY THE TABLE DATA
SELECT * FROM TBL_EMPLOY_MASTER
UPDATE TBL_EMPLOY_MASTER SET EMPADDRESS='BANGALORE,MARATHAHALLI' WHERE EMPID=5
UPDATE TBL_EMPLOY_MASTER SET AGE=30, MOBILE_NUMBER=23432432 
							,DESIGNATION='MANAGER' ,DATE_OF_JOIN='1/1/2020' , ACTIVE=1 WHERE EMPID=5

UPDATE TBL_EMPLOY_MASTER SET AGE=30, MOBILE_NUMBER=4565654654 
							,DESIGNATION='MANAGER' ,DATE_OF_JOIN='1/1/2020' , ACTIVE=1 WHERE EMPID IN (6,7)

BEGIN TRANSACTION
UPDATE TBL_EMPLOY_MASTER SET DESIGNATION='SENIOR MANAGER' 
ROLLBACK

SELECT * FROM TBL_EMPLOY_MASTER

--DELETE THE TABLE DATA
DELETE FROM TBL_EMPLOY_MASTER WHERE EMPID=7

BEGIN TRANSACTION
DELETE FROM TBL_EMPLOY_MASTER 
ROLLBACK

SELECT * FROM TBL_EMPLOY_MASTER

BEGIN TRANSACTION
TRUNCATE TABLE TBL_EMPLOY_MASTER
ROLLBACK

--TRUNCATE TABLE TBL_EMPLOY_MASTER WHERE EMPID=7

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN THE DELETE COMMAND AND TRUNCATE COMMAND
--1. USING DELETE COMMAND WE CAN DELETE ENTIRE TABLE DATA AS WELL AS A SINGLE RECORD
--BUT USING TRUNCATE COMMAND WE CAN REMOVE ENTIRE TABLE DATA BUT NOT A SINGLE RECORD

--2.TRUNCATE IS FASTER THAN DELETE COMMAND

SELECT * INTO TBL_DELETE FROM TBL_EMPLOY_MASTER


SELECT * FROM TBL_DELETE

INSERT INTO TBL_TRUNCATE
SELECT * FROM TBL_TRUNCATE

SELECT * INTO TBL_TRUNCATE FROM TBL_DELETE

SELECT COUNT(*) FROM TBL_DELETE
SELECT COUNT(*) FROM TBL_TRUNCATE

DELETE FROM TBL_DELETE--TOOK 39 SECONDS TO DELETE THE 31 LAKH RECORDS
TRUNCATE TABLE TBL_TRUNCATE--TOOK A MICRO SECOND TO DELETE THE 31 LAKH RECORDS

BEGIN TRANSACTION
TRUNCATE TABLE TBL_TRUNCATE
ROLLBACK

--3.WHEN WE APPLY DELETE, IT WILL DO TWO OPERATION, IT WILL TAKE THE BACKUP EXISTING TABLE DATA 
--AND KEEPS SQL BUFFER MEMORY AND THEN DELETES THE TABLE DATA
--BUT WHEN WE APPLY TRUNCATE, IT WILL JUST REMOVES THE TABLE DATA IT WONT TAKE BACKUP OF EXISTING DATA

--4. WHEN WE APPLY TRUNCATE, WE CAN RESET/RESTART THE IDENTITY SEED  VALUE FROM 1 AGAIN,
-----BUT WE CAN NOT RESET THE IDENTITY SEED VALUE TO START WITH ONE WHEN WE APPLY DELETE.

--5.TRUNCATE IS A DDL COMMAND, AND DELETE IS A DML COMMAND

CREATE TABLE TBL_EMP_IDENT (EMPID INT IDENTITY(1,1), EMPNAME VARCHAR(30),SALARY INT)
INSERT INTO TBL_EMP_IDENT VALUES ('KRISHNA',40000)
INSERT INTO TBL_EMP_IDENT VALUES ('MOHNA',50000)
INSERT INTO TBL_EMP_IDENT VALUES ('RAMESH',60000)
INSERT INTO TBL_EMP_IDENT VALUES ('SURESH',70000)

SELECT * FROM TBL_EMP_IDENT
DELETE FROM TBL_EMP_IDENT

INSERT INTO TBL_EMP_IDENT VALUES ('RAVI',60000)
INSERT INTO TBL_EMP_IDENT VALUES ('UTPAL',70000)

TRUNCATE TABLE TBL_EMP_IDENT

INSERT INTO TBL_EMP_IDENT VALUES ('SWATHI',60000)
INSERT INTO TBL_EMP_IDENT VALUES ('RAMESH',70000)

SELECT * FROM TBL_EMP_IDENT

--DROP COMMAND
--WHAT IS THE DIFFERENCE BETWEEN THE DELETE COMMAND AND DROP COMMAND 
USE [DB_MOHAN]
SELECT * FROM TBL_EMP_IDENT
SELECT * FROM TBL_DELETE

DROP TABLE TBL_EMP_IDENT
DELETE FROM TBL_DELETE
DROP TABLE TBL_DELETE

/*
CONSTRAINTS ARE CONDITIONS DEFINED ON TABLES, FOR VALID DATA STORAGE.			
TYPES OF CONSTRAINTS:				
1.	NOT NULL		: THIS COLUMN DOES NOT ALLOW NULLS. MEANS, MANDATORY COLUMN 
2.	NULL			: THIS COLUMN ALLOW NULLS. MEANS, COLUMN VALUE IS OPTIONAL.
3.	UNIQUE			: THIS COLUMN DOES NOT ALLOW DUPLICATES. ALLOWS UP TO 1 NULL VALUE
4.	PRIMARY KEY		: THIS COLUMN DOES NOT ALLOW DUPLICATES, DOES NOT ALLOW NULL VALUE 

5.	FOREIGN KEY		: THIS IS USED TO REFERENCE / LINK ONE TABLE TO ANOTHER  TABLE.
			SUCH DATABASES THAT CONTAINS RELATIONS ARE "RDB"

6.	CHECK CONSTRAINT :  USED TO SPECIFY CONDITIONS ON COLUMN VALUES.	
7.	DEFAULT CONSTRAINT: USED TO INSERT A DEFAULT VALUE TO THE COLUMN. 	
8.	IDENTITY PROPERTY :  USED TO INSERT AUTOMATED SEQUENCE OF VALUES. EX: 1001, 1002....
 ___________________________________________________________________________  */

CREATE TABLE TBLCOURSES
(
COURSE_ID INT PRIMARY KEY,			-- THIS COLUMN DOES NOT ALLOW DUPLICATES, NULLS		
COURSE_NAME VARCHAR(30) NOT NULL,	-- THIS COLUMN DOES NOT ALLOW NULL VALUES [MANDATORY]	
COURSE_DUR INT CHECK (COURSE_DUR = 120  OR COURSE_DUR = 180)
)

-- QUERY 6: 
CREATE TABLE TBLSTUDENTS
(
STD_ID INT UNIQUE,			-- THIS COLUMN DOES NOT ALLOW DUPLICATES. ALLOW UPTO 1 NULL VALUE
STD_NAME VARCHAR(30),
STD_AGE INT CHECK (STD_AGE >= 18),
STD_COURSE_ID INT REFERENCES TBLCOURSES(COURSE_ID)   -- THIS COLUMN VALUE SHOULD MATCH WITH TBLCOURSES TABLE : COURSE_ID COLUMN
)

CREATE TABLE TBLSTAFF
(
STF_ID INT IDENTITY(100001,1),			-- IDENTITY : USED TO INSERT AUTOMATED SEQUENCE OF VALUES. START VALUE = SEED. 
STF_NAME VARCHAR(30) NOT NULL,			-- THIS COLUMN DOES NOT ALLOW NULL VALUES	
STF_GENDER CHAR CHECK (STF_GENDER IN ('M','F')) DEFAULT 'F',
STF_COURSE_ID INT REFERENCES TBLCOURSES (COURSE_ID)			-- MEANS, STAFF SHOULD BE RECRUITED FOR A VALID COURSE.
)

/* DATABASE DIAGRAMS :  TO AUDIT THE RELATIONS ACROSS TABLES (ER MODELS) IN THE DATABASE. 
IN SSMS : SERVER > DATABASE > RIGHT CLICK "DATABASE DIAGRAM" > INSTALL DIAGRAM SUPPORT.
RIGHT CLICK "DATABASE DIAGRAM" > NEW DATABASE DIAGRAM > SELECT TABLES > ADD > CLOSE.
THIS RESULTS IN ONE "ER DIAGRAM" = ENTITY RELATIONSHIP DIAGRAM. 

SELECT EACH RELATION (LINE B/W TABLES) > RIGHT CLICK > PROPERTIES > WE SEE FOREIGN KEY TABLE & COLUMN
AND CANDIDATE KEY TABLE & COLUMN. CANDIDATE KEY MEANS  : PRIMARY KEY & UNIQUE KEY. */

/*

INDEXES BASICS
INDEXES :  	DATABASE OBJECTS USED FOR FASTER SEARCH OPERATIONS. 
			MEANS, INDEXES ARE NEEDED FOR FASTER EXECUTION OF CONDITIONS USING "WHERE".

BASIC TYPES OF INDEXES:
 1. CLUSTERED INDEX :	THIS INDEX CONTROLS ACTUAL TABLE. MEANS, INDEX DATA IS "CLUSTERED" OR "GROUPED" WITH TABLE. 
						WHENEVER WE DEFINE PRIMARY KEY, ONE CLUSTERED INDEX IS AUTO CREATED.
						A TABLE CAN HAVE ONLY ONE CLUSTERED INDEX. HENCE ONLY ONE PRIMARY KEY.

 2. NON CLUSTERED INDEX : THE INDEX REFERENCES OR DIRECTS THE QUERY TO THE TABLE DATA.
						WHENEVER WE DEFINE UNIQUE KEY, ONE NONCLUSTERED INDEX IS CREATED.
						A TABLE CAN HAVE UPTO 999 NON CLUSTERED INDEXES AND HENCE, UPTO 999 UNIQUE KEY CONSTRAINTS.	
						 					
SYNTAX :  CREATE CLUSTERED  | NONCLUSTERED  INDEX <INDEXNAME>  ON  <TABLE-NAME> ( <<COLUMNNAME>> ) 

MORE INDEXES IN LATER CLASSES (COLUMNSTORE, INCLUDED, FILTERED, ONLINE....) AS PER YOUR COURSE PLAN. */

--	WHILE EXECUTING ABOVE QUERIES, "QUERY OPTIMIZER"  COMPONENT DECIDES THE BEST INDEX TO BE USED 
--	FROM THE AVAILABLE LIST OF INDEXES IN THE TABLE.  


-- VIEWS :		DATABASE OBJECTS USED TO STORE SELECT QUERY
-- FUNCTIONS :	DATABASE OBJECTS USED TO STORE SELECT QUERIES & DML QUERIES
-- PROCEDURES :	DATABASE OBJECTS USED TO STORE SELECT QUERIES, DML QUERIES & DDL QUERIES.

-- TRIGGERS :	DATABASE OBJECTS USED TO STORE SELECT QUERIES, DML QUERIES, DDL QUERIES. AUTO EXECUTION.


--SQL CONSTRAINTS
--PRIMARY KEY, FOREIGN KEY, UNIQUE KEY, DEFAULT , CHECK , NOT NULL, COMPOSITE PRIMARY KEY

--PRIMARY KEY
--IT WONT ALLOW DUPLICATE VALUES TO BE INSERTED ON THE PRIMARY KEY COLUMN
--IT WONT ALLOW NULL VALUES
--PRIMARY KEY WILL PROVIDE UNIQUENESS TO THE TABLE DATA
--WHEN WE CREATE PRIMARY KEY CONSTRAINT, AUTOMATICALLY A CLUSTERED INDEX WILL BE CREATED ON THE TABLE, 
----BECAUSE OF THE CLUSTERED INDEX THE DATA WILL BE ARRANGED ON THE ASCENDING ORDER OF PRIMARY KEY COLUMN (EMPID)
--ONLY ONE PRIMARY KEY IS ALLOWED PER TABLE

CREATE TABLE TBL_EMPL_PRIMARY  (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), SALARY INT)
INSERT INTO TBL_EMPL_PRIMARY VALUES (1,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (2,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (3,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (1,'RAMESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (NULL,'RAKESH',400000)

SELECT * FROM TBL_EMPL_PRIMARY

INSERT INTO TBL_EMPL_PRIMARY VALUES (10,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (5,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (9,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (6,'RAMESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (4,'RAKESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (8,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (11,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (13,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (7,'RAMESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (14,'RAKESH',400000)
INSERT INTO TBL_EMPL_PRIMARY VALUES (12,'KALYAN',400000)

SELECT * FROM TBL_EMPL_PRIMARY

SELECT * FROM TBL_EMPLOY_MASTER WHERE EMPID=4

--CREATE TABLE TBL_EMPLS_DATA (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), MOBILENO BIGINT PRIMARY KEY, PAN_NUMBER VARCHAR(30))

--EVERY EMPLOYEE CAN HAVE ONE PERMANENT ADDRESS AND ONE TEMPORARY ADDRESS
CREATE TABLE TBL_EMPLOY_ADDRESS (EMPID INT, ADDRESS_TYPE VARCHAR(30), EMPAREA VARCHAR(30),
								EMPCITY VARCHAR(30),EMPSTATE VARCHAR(30), PRIMARY KEY(EMPID,ADDRESS_TYPE))

INSERT INTO TBL_EMPLOY_ADDRESS VALUES (1,'PERMANENT','ASHOK NAGAR','TIRUPATHI','ANDHRA')
INSERT INTO TBL_EMPLOY_ADDRESS VALUES (1,'TEMPORARY','KR.NAGAR','BANGALORE','KARNATAKA')

INSERT INTO TBL_EMPLOY_ADDRESS VALUES (2,'PERMANENT','MARUTHI NAGAR','TIRUPATHI','ANDHRA')
INSERT INTO TBL_EMPLOY_ADDRESS VALUES (2,'TEMPORARY','JP NAGAR','BANGALORE','KARNATAKA')

INSERT INTO TBL_EMPLOY_ADDRESS VALUES (1,'PERMANENT','MARUTHI NAGAR','TIRUPATHI','ANDHRA')

--UNIQUE KEY
--IT WONT ALLOW DUPLICATE VALUES
--IT WILL ALLOW ONLY ONE NULL VALUE
--WHEN WE CREATE UNIQUE KEY, BY DEFAULT NONCLUSTERED INDEX WILL BE CREATED ON THE TABLE
--NON CLUSTERED INDEX WILL A CREATE INDEX PAGE FOR THE TABLE DATA, IN WHICH IT CONTAINS POINTERS TO THE ROW DATA

CREATE TABLE TBL_EMPLS_DATA (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), MOBILENO BIGINT UNIQUE, PAN_NUMBER VARCHAR(30) UNIQUE)
INSERT INTO TBL_EMPLS_DATA VALUES (1,'KRISHNA',98797987,'ALGGLUOU787')
INSERT INTO TBL_EMPLS_DATA VALUES (2,'MOHAN',98797987,'ALGGLUOU780')
INSERT INTO TBL_EMPLS_DATA VALUES (2,'MOHAN',NULL,'ALGGLUOU780')
INSERT INTO TBL_EMPLS_DATA VALUES (3,'RAMESH',NULL,'ALGGLUOU780')

SELECT * FROM TBL_EMPLOY_MASTER WHERE EMPID=4
SELECT * FROM TBL_EMPLOY_MASTER WHERE EMPID=950

--FOREIGN KEY CONSTRAINT
--IT WILL MAKE SURE THAT THERE ARE NO ORPHAN RECORDS PRESENT IN THE TABLE
--USING FOREIGN KEY CONSTRAINT, WE CAN MAINTAIN THE REFERENTIAL INTEGRITY BETWEEN THE DATABASE TABLES
--FOREIGN KEY IS USED TO CREATE RELATIONSHIPS BETWEEN THE TWO TABLES

SELECT * FROM TBL_EMPL_PRIMARY
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY

CREATE TABLE TBL_EMPLS_LEAVE_HISTORY (EMPID INT FOREIGN KEY REFERENCES TBL_EMPL_PRIMARY(EMPID) ON DELETE CASCADE, 
										LEAVE_FROM DATE, LEAVE_UPTO DATE, NO_OF_DAYS INT)
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (1,'12/23/2019','12/24/2019',2)
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (5,'11/23/2019','11/25/2019',3)
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (9,'10/23/2019','10/24/2019',2)
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (14,'12/23/2019','12/24/2019',2)
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (16,'9/23/2019','9/24/2019',2)

--DROP TABLE TBL_EMPLS_LEAVE_HISTORY   

USE [DB_MOHAN]
DELETE FROM TBL_EMPL_PRIMARY WHERE EMPID=5
DELETE FROM TBL_EMPLS_LEAVE_HISTORY WHERE EMPID=5

CREATE TABLE TBL_EMPLS_ADDRESS (EMPID INT FOREIGN KEY REFERENCES TBL_EMPL_PRIMARY(EMPID) ON DELETE CASCADE
								, EMPNAME VARCHAR(30), ADDRESS1 VARCHAR(30), CITY VARCHAR(30))
INSERT INTO TBL_EMPLS_ADDRESS VALUES (1,'KRISHNA','KR.PURAM','BANGALORE')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (2,'RAMESH','JP NAGAR','BANGALORE')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (3,'SURESH','JAYA NAGAR','BANGALORE')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (4,'VARUN','KR.PURAM','BANGALORE')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (5,'MOHAN','KR.PURAM','BANGALORE')

SELECT * FROM TBL_EMPL_PRIMARY WHERE EMPID=1
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY WHERE EMPID=1
SELECT * FROM TBL_EMPLS_ADDRESS WHERE EMPID=1

DELETE FROM TBL_EMPL_PRIMARY WHERE EMPID=1

--CHECK CONSTRAINT
--EVERY EMPLOYEE AGE SHOULD BE GREATER THAN OR EQUAL TO 25 YEARS
--EVER EMPLOYEE MIN SALARY SHOULD BE GREATER THAN 10000

CREATE TABLE TBL_EMPLS_SALARY (EMPID INT, EMPNAME VARCHAR(30), AGE INT CHECK(AGE>=25), 
								GENDER CHAR(1), SALARY INT CHECK(SALARY>=10000), DESG VARCHAR(30))
INSERT INTO TBL_EMPLS_SALARY VALUES (1,'KRISHNA',24,'M',20000,'TECH LEAD')
INSERT INTO TBL_EMPLS_SALARY VALUES (1,'KRISHNA',26,'M',9000,'TECH LEAD')
INSERT INTO TBL_EMPLS_SALARY VALUES (1,'KRISHNA',26,'M',20000,'TECH LEAD')

CREATE TABLE TBL_EMPLS_SALARY2 (EMPID INT, EMPNAME VARCHAR(30), AGE INT, 
								GENDER CHAR(1), SALARY INT, DESG VARCHAR(30), CHECK(AGE>=25 OR SALARY>=10000))
INSERT INTO TBL_EMPLS_SALARY2 VALUES (1,'KRISHNA',24,'M',20000,'TECH LEAD')
INSERT INTO TBL_EMPLS_SALARY2 VALUES (1,'KRISHNA',26,'M',9000,'TECH LEAD')
INSERT INTO TBL_EMPLS_SALARY2 VALUES (1,'KRISHNA',20,'M',8000,'TECH LEAD')

--DEFAULT VALUE AND NOT NULL
SELECT GETDATE()

CREATE TABLE TBL_EMPLS_PROJECT (EMPID INT NOT NULL, EMPNAME VARCHAR(30), 
								EMPLS_PROJECT VARCHAR(30) DEFAULT('PROCUREMENT PROJECT'), AGE INT,
								CREATED_DATE DATE DEFAULT(GETDATE()))
INSERT INTO TBL_EMPLS_PROJECT VALUES (1,'KRISHNA','INVENTORY PROJECT',35)
INSERT INTO TBL_EMPLS_PROJECT VALUES (2,'MOHAN',NULL,35)
INSERT INTO TBL_EMPLS_PROJECT VALUES (3,'SURESH','',35)
INSERT INTO TBL_EMPLS_PROJECT (EMPID,EMPNAME, AGE) VALUES (4,'RAMESH',26)
INSERT INTO TBL_EMPLS_PROJECT (EMPID,EMPNAME, AGE) VALUES (NULL,'RAMESH',26)

SELECT * FROM TBL_EMPLS_PROJECT


--CREATING PRIMARY KEY CONSTRAINT ON AN EXISTING TABLE

CREATE TABLE TBL_EMPL_PRIMARY2  (EMPID INT, EMPNAME VARCHAR(30), SALARY INT)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (1,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (2,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (3,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (10,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (5,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (9,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (6,'RAMESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (4,'RAKESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (8,'KRISHNA',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (11,'MOHAN',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (13,'SURESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (7,'RAMESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (14,'RAKESH',400000)
INSERT INTO TBL_EMPL_PRIMARY2 VALUES (12,'KALYAN',400000)

SELECT * FROM TBL_EMPL_PRIMARY2
SP_HELP TBL_EMPL_PRIMARY2

ALTER TABLE TBL_EMPL_PRIMARY2 ALTER COLUMN EMPID INT NOT NULL
ALTER TABLE TBL_EMPL_PRIMARY2 ADD PRIMARY KEY (EMPID)

;WITH CTE_DUPLICATE
AS
(
SELECT *,ROW_NUMBER()OVER(PARTITION BY EMPID ORDER BY EMPID ASC) AS R_NO FROM TBL_EMPL_PRIMARY2
)
SELECT * FROM CTE_DUPLICATE WHERE R_NO>1
--DELETE FROM CTE_DUP WHERE R_NO>1

SELECT * FROM TBL_EMPL_PRIMARY2 ORDER BY EMPID

--LIST OF OPERATORS IN SQL SERVER
--=, <>, IN, NOT IN, >=, <=, BETWEEN, LIKE, AND, OR, IF EXISTS, OBJECT ID
USE [DB_MOHAN]
SELECT * INTO TBL_EMPL_MASTER FROM DB_MOHAN.DBO.TBL_EMPLOY_MASTER

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID = 5
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID != 5

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID IN (5,6,7)
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID NOT IN (5,6,7)
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY >= 25000
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY <= 25000

SELECT * FROM TBL_EMPL_MASTER WHERE SALARY >=25000 AND SALARY <=30000
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY BETWEEN 25000 AND 30000

SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE 'S%'
SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE '%A'
SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE '%H%'

SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE 'S%' OR EMPNAME LIKE 'K%'
SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE '[K,S,V]%' 

SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE '_____'
SELECT * FROM TBL_EMPL_MASTER WHERE EMPNAME LIKE '______'

SELECT * FROM TBL_EMPL_MASTER WHERE SALARY >25000 AND EMPCITY='CHENNAI'
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY >25000 OR EMPCITY='CHENNAI'

--EXISTS OPERATOR
IF EXISTS (SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1)
BEGIN
PRINT 'YES THE EMPLOYEE EXISTS IN THE GIVEN TABLE'
END
ELSE
PRINT 'NO THE EMPLOYEE IS NOT PRESENT IN THE TABLE'

---
IF EXISTS (SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=100)
BEGIN
PRINT 'YES THE EMPLOYEE EXISTS IN THE GIVEN TABLE'
END
ELSE
PRINT 'NO THE EMPLOYEE IS NOT PRESENT IN THE TABLE'

--OBJECTID
IF OBJECT_ID('TBL_EMPL_MASTER')>0
BEGIN
PRINT 'YES THE TABLE IS PRESENT IN THIS DATABASE'
END
ELSE
PRINT 'NO THE TABLE IS NOT PRESENT IN THIS DATABASE'

---------------
IF OBJECT_ID('TBL_EMPL_MASTER001')>0
BEGIN
PRINT 'YES THE TABLE IS PRESENT IN THIS DATABASE'
END
ELSE
PRINT 'NO THE TABLE IS NOT PRESENT IN THIS DATABASE'

SELECT OBJECT_ID FROM SYS.OBJECTS WHERE TYPE='U' AND NAME='TBL_EMPL_MASTER'
SELECT OBJECT_ID FROM SYS.OBJECTS WHERE TYPE='U' AND NAME='TBL_EMPL_MASTER001'

--GROUP BY ALONG WITH HAVING CLAUSE

SELECT * FROM TBL_EMPL_MASTER

SELECT SUM(SALARY) AS TOTAL_SALARY FROM [dbo].[TBL_EMPLS_SALARY]

SELECT EMPCITY,SUM(SALARY) AS TOTAL_SALARY FROM TBL_EMPL_MASTER GROUP BY EMPCITY

SELECT EMPCITY,SUM(SALARY) AS TOTAL 
FROM TBL_EMPL_MASTER 
WHERE EMPCITY IN ('CHENNAI','HYDERABAD','BANGALORE','COCHIN')
GROUP BY EMPCITY
HAVING SUM(SALARY)>=200000
ORDER BY TOTAL ASC

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN THE WHERE CLAUSE AND HAVING CLAUSE
--1.WHERE CLAUSE IS USED TO APPLY FILTER CONDITIONS BEFORE GROUPING THE DATA
--HAVING CLAUSE IS USED TO APPLY FILTER CONDITIONS AFTER GROUPING THE DATA

--2.IN HAVING CLAUSE I CAN APPLY FILTERS ON THE AGGREGATE FUNCTIONS BUT THE SAME IS NOT POSSIBLE IN WHERE CLAUSE

--QUESTION: HOW MANY TYPES OF CLAUSES ARE THERE IN SQL SERVER
--SELECT CLAUSE, FROM CLAUSE, WHERE CLAUSE, GROUP BY CLAUSE, HAVING CLAUSE, ORDER BY CLAUSE

--3. WHAT IS THE ORDER OF EXECUTION OF THE SQL CLAUSES
--1.FROM ,2.WHERE, 3.GROUP BY, 4.HAVING ,5.SELECT ,6.ORDER BY

SELECT EMPCITY,SUM(SALARY) AS TOTAL 
FROM TBL_EMPL_MASTER --1 LAKH
WHERE EMPCITY IN ('CHENNAI','HYDERABAD','BANGALORE','COCHIN')--40000
GROUP BY EMPCITY --4 
HAVING SUM(SALARY)>=200000--2
ORDER BY TOTAL ASC


-- REQUIREMENT 3:	HOW TO REPORT LIST OF FLIGHTS AND RESPECTIVE RESERVATIONS (MATCHING DATA)? INNER JOIN
SELECT * FROM FLIGHT			-- THIS IS LEFT TABLE
INNER JOIN 
RESERVATION						-- THIS IS RIGHT TABLE
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE

-- REQUIREMENT 4:	HOW TO REPORT LIST OF ALL FLIGHTS WITH & WITHOUT RESERVATIONS (MATCHING, MISSING DATA) ?
SELECT * FROM FLIGHT
LEFT OUTER JOIN		-- ALL LEFT TABLE DATA + MATCHING RIGHT TABLE DATA. NON MATCH RIGHT TABLE DATA IS NULL. 
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE


-- REQUIREMENT 5:	HOW TO REPORT LIST OF FLIGHTS WITHOUT RESERVATIONS (TO REPORT ONLY MISSING DATA)?
SELECT * FROM FLIGHT
LEFT OUTER JOIN		-- ALL LEFT TABLE DATA + MATCHING RIGHT TABLE DATA. NON MATCH RIGHT TABLE DATA IS NULL. 
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE
WHERE 
RESERVATION.AIR_CRAFT_CODE IS NULL			-- TO FIND MISSING DATA



-- REQUIREMENT 6:	HOW TO REPORT LIST OF FLIGHTS WITH RESERVATIONS (TO REPORT ONLY MATCHING DATA)?
SELECT * FROM FLIGHT
LEFT OUTER JOIN		-- ALL LEFT TABLE DATA + MATCHING RIGHT TABLE DATA. NON MATCH RIGHT TABLE DATA IS NULL. 
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE
WHERE
RESERVATION.AIR_CRAFT_CODE IS NOT NULL		-- TO FIND MATCHING DATA


-- REQUIREMENT 7:	HOW TO REPORT LIST OF FLIGHTS WITH & WITHOUT RESERVATIONS USING "RIGHT OUTER" JOIN?
SELECT * FROM  RESERVATION		-- THIS IS LEFT TABLE
RIGHT OUTER JOIN				-- ALL RIGHT + MATCHING LEFT. NON MATCH LEFT IS NULL
FLIGHT							-- THIS IS RIGHT TABLE
ON
FLIGHT.AIR_CRAFT_CODE = RESERVATION.AIR_CRAFT_CODE



-- REQ 8: REPORT LIST OF FLIGHTS WITH & WITHOUT RESERVATIONS, LIST OF RESERVATIONS WITH & WITHOUT FLIGHTS?
SELECT * FROM  FLIGHT 
FULL OUTER JOIN					-- THIS IS A COMBINATION OF BOTH LEFT OUTER JOIN  + RIGHT OUTER JOIN
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE


-- EXAMPLE FOR CROSS JOIN:
SELECT * FROM  FLIGHT	CROSS JOIN	RESERVATION			-- 3 FLIGHTS, 6 RESERVATIONS. MEANS : 18 COMBINATONS
SELECT * FROM  FLIGHT	CROSS APPLY RESERVATION
SELECT * FROM  FLIGHT , RESERVATION


/*
WHEN WORKING WITH BIG DATA, IT IS ADVISABLE TO USE "JOIN OPTIONS" FOR FASTER QUERY EXECUTIONS. 
		I.   MERGE JOIN OPTION	:	USED TO JOIN BIGGER TABLES (TABLES WITH MORE THAN 100M ROWS)
		II.  LOOP JOIN OPTION	:	USED TO JOIN SMALL TABLES  (TABLES WITH LESS THAN 100M ROWS)
		III. HASH JOIN OPTION	:	USED TO JOIN HEAP TABLES   (TABLES WITHOUT PRIMARY KEY)
*/

SELECT * FROM FLIGHT
INNER MERGE JOIN					-- FOR BIG TABLES
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE


SELECT * FROM FLIGHT
INNER LOOP JOIN						-- FOR SMALL TABLES
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE


SELECT * FROM FLIGHT
LEFT OUTER HASH JOIN						-- FOR HEAP TABLES
RESERVATION
ON
RESERVATION.AIR_CRAFT_CODE = FLIGHT.AIR_CRAFT_CODE


-- EXAMPLE SCENARIO FOR CROSS APPLY:
SELECT  TOP 50  TOTAL_WORKER_TIME / EXECUTION_COUNT AS AVG_EXEC_TIME,*
FROM SYS.DM_EXEC_QUERY_STATS
CROSS APPLY						-- THIS IS SIMILAR TO CROSS JOIN
SYS.DM_EXEC_SQL_TEXT (PLAN_HANDLE)
ORDER BY  AVG_EXEC_TIME DESC 

SELECT * FROM SYS.DM_EXEC_QUERY_STATS

-- EXAMPLES TO JOINS THREE TABLES:
--SYNTAX	:		(A JOIN B) JOIN C

--JOINS
--IF WE WANT TO COMBINE THE TWO TABLES DATA BY COLUMN WISE, THEN WE HAVE TO USE JOINS
SELECT EMPID,EMPNAME,AGE,DESIGNATION FROM TBL_EMPL_MASTER
SELECT EMPID,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPLS_LEAVE_HISTORY

SELECT TBL_EMPL_MASTER.EMPID,TBL_EMPL_MASTER.EMPNAME,TBL_EMPL_MASTER.AGE,TBL_EMPL_MASTER.DESIGNATION,
		TBL_EMPLS_LEAVE_HISTORY.EMPID,TBL_EMPLS_LEAVE_HISTORY.LEAVE_FROM,TBL_EMPLS_LEAVE_HISTORY.LEAVE_UPTO
FROM TBL_EMPL_MASTER 
JOIN TBL_EMPLS_LEAVE_HISTORY ON TBL_EMPL_MASTER.EMPID=TBL_EMPLS_LEAVE_HISTORY.EMPID

SELECT EMP.EMPID,EMP.EMPNAME,EMP.AGE,EMP.DESIGNATION,
	   LEV.EMPID,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,
	   ACCOUNT_NO,BRANCH_NAME,BANK_NAME
FROM   TBL_EMPL_MASTER AS EMP
JOIN   TBL_EMPLS_LEAVE_HISTORY AS LEV ON EMP.EMPID=LEV.EMPID
JOIN   TBL_EMPLS_BANK_DETAILS AS BNK ON EMP.EMPID=BNK.EMPID

SELECT * FROM TBL_EMPLS_BANK_DETAILS
--WITH CTE_DUP
--AS
--(SELECT *,ROW_NUMBER()OVER(PARTITION BY EMPID ORDER BY EMPID) AS R_NO FROM TBL_EMPLS_BANK_DETAILS) 
--DELETE FROM CTE_DUP WHERE R_NO>1


SELECT TOP 6 * INTO TBL_EMPLOYS_DATA FROM TBL_EMPL_MASTER
SELECT * INTO TBL_EMPLOYS_LEAVE_DATA FROM TBL_EMPLS_LEAVE_HISTORY ORDER BY EMPID 
SELECT TOP 2 * INTO TBL_EMPLOYS_BANK_DATA FROM TBL_EMPLS_BANK_DETAILS
SELECT * FROM TBL_EMPLOYS_DATA
SELECT * FROM TBL_EMPLOYS_LEAVE_DATA ORDER BY EMPID
SELECT * FROM TBL_EMPLOYS_BANK_DATA
INSERT INTO TBL_EMPLOYS_BANK_DATA VALUES (7,786576576575,'MADIWALA','HDFC',1)
INSERT INTO TBL_EMPLOYS_LEAVE_DATA VALUES (1,'1/23/2020','1/25/2020',2)

--TYPES OF JOINS
--INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN, SELF JOIN

--INNER JOIN (OR JOIN)
--INNER JOIN WILL SHOW ONLY THE MATCHING ROWS PRESENT IN BOTH THE TWO TABLES
SELECT * FROM TBL_EMPLOYS_DATA EMP 
INNER JOIN TBL_EMPLOYS_LEAVE_DATA LEV ON EMP.EMPID =LEV.EMPID--1,2,3,4
RIGHT OUTER JOIN TBL_EMPLOYS_BANK_DATA BNK ON BNK.EMPID=EMP.EMPID--1,3,7

--LEFT OUTER JOIN (LEFT JOIN)
--LEFT OUTER JOIN WILL SHOW THE MATCHING ENTRIES PRESENT IN BOTH THE TWO TABLES 
--AS WELL AS THE UNMATCHED ENTRIES PRESENT IN THE LEFT TABLE
SELECT * FROM TBL_EMPLOYS_DATA EMP LEFT OUTER JOIN TBL_EMPLOYS_LEAVE_DATA LEV ON EMP.EMPID =LEV.EMPID

--RIGHT OUTER JOIN (RIGHT JOIN)
--RIGHT OUTER JOIN WILL SHOW THE MATCHING ENTRIES PRESENT IN BOTH THE TWO TABLES 
--AS WELL AS THE UNMATCHED ENTRIES PRESENT IN THE RIGHT TABLE
SELECT * FROM TBL_EMPLOYS_DATA EMP RIGHT OUTER JOIN TBL_EMPLOYS_LEAVE_DATA LEV ON EMP.EMPID =LEV.EMPID
ORDER BY LEV.EMPID

--FULL OUTER JOIN (FULL JOIN)
--FULL OUTER JOIN WILL SHOW THE MATCHING ENTRIES PRESENT IN BOTH THE TWO TABLES 
--AS WELL AS THE UNMATCHED ENTRIES PRESENT IN BOTH THE TABLES
SELECT * FROM TBL_EMPLOYS_DATA EMP FULL OUTER JOIN TBL_EMPLOYS_LEAVE_DATA LEV ON EMP.EMPID =LEV.EMPID

--CROSS JOIN
SELECT * FROM TBL_EMPLOYS_DATA EMP CROSS JOIN TBL_EMPLOYS_LEAVE_DATA LEV
WHERE EMP.EMPID=2

CREATE TABLE TBL_STUDENT_MARKS (STUDENTID INT, SUBJECT_NAME VARCHAR(30), MARKS INT)
INSERT INTO TBL_STUDENT_MARKS VALUES (1,'PHYSICS',92)
INSERT INTO TBL_STUDENT_MARKS VALUES (2,'PHYSICS',65)
INSERT INTO TBL_STUDENT_MARKS VALUES (3,'PHYSICS',55)
INSERT INTO TBL_STUDENT_MARKS VALUES (4,'PHYSICS',75)
INSERT INTO TBL_STUDENT_MARKS VALUES (5,'PHYSICS',85)

CREATE TABLE TBL_GRADE (MIN_MARKS INT, MAX_MARKS INT, GRADE VARCHAR(5))
INSERT INTO TBL_GRADE VALUES (0,50,'E')
INSERT INTO TBL_GRADE VALUES (51,60,'D')
INSERT INTO TBL_GRADE VALUES (61,70,'C')
INSERT INTO TBL_GRADE VALUES (71,80,'B')
INSERT INTO TBL_GRADE VALUES (81,90,'A')
INSERT INTO TBL_GRADE VALUES (91,100,'A+')

SELECT * FROM TBL_STUDENT_MARKS 
SELECT * FROM TBL_GRADE

SELECT * FROM TBL_STUDENT_MARKS STD CROSS JOIN TBL_GRADE GR 
WHERE STD.STUDENTID=1 AND MARKS BETWEEN MIN_MARKS AND MAX_MARKS

SELECT STD.*,GR.GRADE FROM TBL_STUDENT_MARKS STD CROSS JOIN TBL_GRADE GR 
WHERE  MARKS BETWEEN MIN_MARKS AND MAX_MARKS

SELECT  EMP_ID, EMP_FNAME + EMP_LNAME FROM EMPLOYEE_INFO	-- APPEND MEANS TO ADD. TO COMBINE CHARACTER DATA. NOTE: COLUMN NAME IS MISSING
SELECT  EMP_ID, EMP_FNAME + EMP_LNAME AS FULLNAME FROM EMPLOYEE_INFO  -- AS MEANS : ALIASING. GIVING A NEW NAME TO THE COLUMN
SELECT  EMP_ID, EMP_FNAME + EMP_LNAME AS "FULL NAME" FROM EMPLOYEE_INFO
SELECT  EMP_ID, EMP_FNAME + EMP_LNAME AS [FULL NAME] FROM EMPLOYEE_INFO


-- QUERY 26 : HOW TO REPORT 3RD AND REMAINING ALL EMPLOYEES ? 
 SELECT * FROM EMPLOYEE_INFO ORDER BY EMP_ID
 SELECT * FROM EMPLOYEE_INFO ORDER BY EMP_ID ASC OFFSET 2 ROWS		
 SELECT * FROM EMPLOYEE_INFO ORDER BY EMP_ID ASC OFFSET 1 ROWS		
 SELECT * FROM EMPLOYEE_INFO ORDER BY EMP_ID ASC OFFSET 3 ROWS		

-- QUERY 27 : HOW TO REPORT 3RD AND REMAINING 3 EMPLOYEES ? 
SELECT * FROM EMPLOYEE_INFO ORDER BY EMP_ID ASC OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY 

-- TOP	:	TO REPORT SPECIFIED NUMBER OF ROWS FROM THE BEGINNING OF RESULT
-- OFFSET:	TO REPORT REMAINING ROWS EXCEPT THE SPECIIFED NUMBER OF ROWS FROM THE BEGINNING OF RESULT

-- HOW TO REPORT ALL ROWS EXCEPT 1 TO 10 ?
SELECT * FROM PRODUCTS_DATA ORDER BY PRODUCTKEY OFFSET 10 ROW

-- HOW TO REPORT ALL ROWS 11 TO 15 ROWS?
SELECT * FROM PRODUCTS_DATA ORDER BY PRODUCTKEY OFFSET 10 ROW FETCH NEXT 5 ROWS ONLY

-- HOW TO REPORT 11TH ROW ONLY?
SELECT * FROM PRODUCTS_DATA ORDER BY PRODUCTKEY ASC OFFSET 10 ROW FETCH NEXT 1 ROWS ONLY



-- HOW TO MODIFY STRUCTURE OF ABOVE TABLE TO ADD NEW COLUMN?			
ALTER TABLE EMPLOYEE_INFO ADD EMP_GENDER CHAR(5)


--SELF JOINS
--IF WE JOIN A TABLE AGAIN BACK WITH THE SAME TABLE, THEN THAT TYPE OF JOIN SELF JOIN
--IN CASE EMPLOYEE-MANAGER RELATION

SELECT * INTO TBL_EMPLOYEE_MGR FROM [DB_MOHAN].DBO.TBL_EMPLOYEE_MGR

SELECT		EMP.EMPID,EMP.EMPNAME,EMP.SALARY,EMP.DESIGNATION,MGR.EMPNAME AS MANAGER_NAME
FROM		TBL_EMPLOYEE_MGR EMP
LEFT JOIN	TBL_EMPLOYEE_MGR MGR ON EMP.MANAGER_ID=MGR.EMPID

SELECT * FROM TBL_EMPLOYEE_MGR

SELECT		EMP.EMPID,EMP.EMPNAME,EMP.SALARY,EMP.DESIGNATION,MGR.EMPNAME AS MANAGER_NAME
FROM		TBL_EMPLOYEE_MGR EMP
INNER JOIN	TBL_EMPLOYEE_MGR MGR ON EMP.MANAGER_ID=MGR.EMPID

--UNION
--IF WE WANT TO COMBINE THE TWO TABLES DATA BY ROW WISE, THEN WE HAVE TO USE UNION
SELECT EMPID,LTRIM(EMPNAME) AS EMPNAME, AGE, DESIGNATION, EMPCITY INTO TBL_EMPLS_BANGALORE FROM TBL_EMPL_MASTER WHERE EMPCITY='BANGALORE'
SELECT EMPID,LTRIM(EMPNAME) AS EMPNAME, AGE, DESIGNATION, EMPCITY INTO TBL_EMPLS_HYD FROM TBL_EMPL_MASTER WHERE EMPCITY='HYDERABAD'
SELECT EMPID,LTRIM(EMPNAME) AS EMPNAME, AGE, DESIGNATION, EMPCITY INTO TBL_EMPLS_CHENNAI FROM TBL_EMPL_MASTER WHERE EMPCITY='CHENNAI'

SELECT * FROM TBL_EMPLS_BANGALORE
UNION
SELECT * FROM TBL_EMPLS_HYD
UNION
SELECT * FROM TBL_EMPLS_CHENNAI

SELECT * FROM TBL_EMPLS_HYD

--UNION
--IT WILL COMBINE THE TWO OR MORE TABLES DATA, AS WELL AS IT WILL REMOVE THE DUPLICATES AND IT WILL SORT THE RESULT SET DATA

--UNION ALL
--IT WILL JUST COMBINE THE TWO OR MORE TABLES DATA, IT WONT REMOVE THE DUPLICATES AND IT WONT SORT THE RESULT SET DATA
--UNION ALL WILL BE FASTER THAN UNION COMMAND
SELECT * FROM TBL_EMPLS_BANGALORE
UNION ALL
SELECT * FROM TBL_EMPLS_HYD
UNION ALL
SELECT * FROM TBL_EMPLS_CHENNAI

--PRE-REQUISITES BEFORE APPLYING UNION OR UNION ALL
--1. THE NUMBER OF COLUMNS SHOULD BE SAME IN BOTH THE QUERIES
--2. THE CORRESPONDING COLUMNS DATA TYPES SHOULD MATCH

SELECT EMPID,EMPNAME,AGE,DESIGNATION,EMPCITY FROM TBL_EMPLS_BANGALORE
UNION
SELECT EMPID,EMPNAME,AGE,DESIGNATION,'' AS EMPCITY FROM TBL_EMPLS_HYD

SELECT EMPID,EMPNAME,AGE,DESIGNATION,EMPCITY FROM TBL_EMPLS_BANGALORE
UNION
SELECT EMPNAME,EMPID,AGE,DESIGNATION,EMPCITY FROM TBL_EMPLS_HYD

--INTERSECT AND EXCEPT

--INTERSECT WILL SHOW THE COMMON RECORDS PRESENT IN BOTH THE TABLES
SELECT * FROM TBL_EMPLS_BANGALORE
INTERSECT
SELECT * FROM TBL_EMPLS_HYD

--EXCEPT
SELECT * FROM TBL_EMPLS_BANGALORE
UNION
SELECT * FROM TBL_EMPLS_HYD

SELECT UPPER(EMPNAME),AGE,UPPER(DESIGNATION),UPPER(EMPCITY) FROM TBL_EMPLS_HYD
EXCEPT
SELECT EMPNAME,AGE,DESIGNATION,EMPCITY FROM TBL_EMPLS_BANGALORE

-- GROUP BY	:	 USED TO REPORT UNIQUE VALUES OF A COLUMN & PERFORM AGGREGATIONS (SUM, MIN, MAX ..)
-- HAVING	:	 USED TO SPECIFY CONDITIONS ON THE GROUP BY COLUMNS.

-- QUERY 8: HOW TO GIVE CONDITIONS ON GROUP BY (AGGREGATED) DATA ?
SELECT COUNTRY, STATE, CITY, SUM(POPULATION) AS TOTAL_POP FROM TBLPOPULATION
GROUP BY COUNTRY , STATE, CITY
HAVING SUM(POPULATION) > 15

-- QUERY 10: HOW TO REPORT TOTAL POPULATION USING ROLLUP  ?
SELECT  COUNTRY,  SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY COUNTRY

SELECT  COUNTRY,  SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY)

SELECT  ISNULL(COUNTRY, 'GRAND TOTAL'), SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY)

SELECT  ISNULL(COUNTRY, 'GRAND TOTAL') AS COUNTRY, SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY)

SELECT  COALESCE(COUNTRY, 'GRAND TOTAL') AS COUNTRY , SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY)


-- GROUPING : 0  = ORIGINAL ROW DATA.   1 = NEW ROW DATA
SELECT  ISNULL(COUNTRY, 'GRAND TOTAL') AS COUNTRY, SUM(POPULATION) AS TOTAL_POPULATION,
GROUPING(COUNTRY)  FROM TBLPOPULATION	
GROUP BY ROLLUP(COUNTRY)				

-- QUERY 11: HOW TO REPORT TOTAL POPULATION USING ROLLUP  ?
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE)			-- COUNTRY WISE TOTALS + COUNTRY, STATE WISE TOTALS

SELECT  COALESCE(COUNTRY, 'GRAND TOTAL') AS  COUNTRY, ISNULL(STATE, 'COUNTRY WISE TOTAL')  AS STATE, SUM(POPULATION) AS TOTAL_POPULATION ,
GROUPING(COUNTRY),GROUPING(STATE) 
FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE)			-- COUNTRY WISE TOTALS + COUNTRY, STATE WISE TOTALS

-- QUERY 12: HOW TO REPORT TOTAL POPULATION USING CUBE  ?
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION FROM TBLPOPULATION
GROUP BY CUBE(COUNTRY, STATE)			-- COUNTRY WISE TOTALS + COUNTRY, STATE WISE TOTALS + STATE WISE TOTALS

-- QUERY 13: HOW TO REPORT SUB TOTALS, GRAND TOTALS WITH ROW STATUS ?
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE)  --  0 MEANS ORIGINAL DATA.   1 MEANS NEW ROW


-- QUERY 14: HOW TO REPORT ONLY SUB TOTALS AND GRAND TOTALS?
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 1			-- AGGREGATE FUNCTION IS GROUPING()

SELECT  COUNTRY,  SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 1			-- AGGREGATE FUNCTION IS GROUPING()


SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 0


-- QUERY 15: HOW TO REPORT ACTUAL DATA, SUB TOTALS, GRAND TOTALS IN ORDER?
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 0
UNION ALL
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 1


CREATE VIEW VW_QUERYSTORE
AS
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 0
UNION ALL
SELECT  COUNTRY, STATE, SUM(POPULATION) AS TOTAL_POPULATION, 
GROUPING(STATE) AS ROW_STATUS  FROM TBLPOPULATION
GROUP BY ROLLUP(COUNTRY, STATE) 
HAVING GROUPING(STATE) = 1

--SYSTEM FUNCTIONS
--SCALAR FUNCTIONS, AGGREGATE FUNCTIONS

--AGGREGATE FUNCTIONS
--THE FUNCTIONS WHICH WE APPLY ON GROUP OF RECORDS ARE CALLED AS AGGREGATE FUNCTIONS
--SUM,AVERAGE, MIN, MAX, COUNT
SELECT   EMPCITY,SUM(SALARY) AS TOTAL_SALARY, AVG(SALARY) AS AVG_SALARY,
		MIN(SALARY) AS MIN_SAL,MAX(SALARY) AS MAX_SALARY,COUNT(EMPID) AS COUNT_OF_EMPLS 
FROM	TBL_EMPL_MASTER GROUP BY EMPCITY

SELECT * FROM TBL_EMPL_MASTER WHERE EMPCITY='BANGALORE'--289000/4
SELECT 289000/4

--SCALAR FUNCTIONS
--THE FUNCTIONS WHICH WE APPLY ON EACH INDIVIDUAL RECORDS SEPARATELY, THOSE FUNCTIONS ARE CALLED AS SCALAR FUNCTIONS


SELECT GETDATE()									-- REPORTS CURRENT DATE & TIME

SELECT CONVERT(VARCHAR(30), GETDATE(), 101)			-- MM/DD/YYYY   (STYLES)
SELECT CONVERT(VARCHAR(40), GETDATE(), 102)			-- YYYY.MM.DD
SELECT CONVERT(VARCHAR(20), GETDATE(), 103)			-- DD/MM/YYYY
SELECT CONVERT(VARCHAR(35), GETDATE(), 104)			-- DD.MM.YYYY
SELECT CONVERT(VARCHAR(30), GETDATE(), 105)			-- DD-MM-YYYY
SELECT CONVERT(VARCHAR(30), GETDATE(), 106)			-- DD MON YYYY
SELECT CONVERT(VARCHAR(30), GETDATE(), 107)			-- MON DD, YYYY

SELECT CONVERT(VARCHAR(30), GETDATE(), 108)			-- TIME 

SELECT CONVERT(VARCHAR(30), GETDATE(), 109)			-- DATE & TIME

SELECT YEAR(GETDATE())
SELECT MONTH(GETDATE())
SELECT DAY(GETDATE())

SELECT DATEDIFF(D, '2019-12-12', '2020-12-12') 		-- REPORTS DIFFERENCE IN DAYS
SELECT DATEADD(D, 60, '2020-01-31')					-- ADDS N NUMBER OF DAYS TO EXISTING DATE

SELECT REPLACE('SQL SERVER', 'SQL','SEQUEL')	-- REPLACE TEXT IN A GIVEN STRING
SELECT REVERSE('SQL SERVER')					-- REVERSE THE TEXT
SELECT LEN('SQL SERVER')						-- REPORTS NUMBER OF CHARACTERS
SELECT UPPER('SQL SERVER')						-- REPORTS UPPER CASE TEXT
SELECT LOWER('SQL SERVER')						-- REPORTS LOWER CASE TEXT
SELECT SUBSTRING('SQL SERVER', 5, 3)			-- REPORTS 3 CHARACTERS FROM 5TH POSITION
SELECT LEFT('SQL SERVER', 3)					-- REPORTS STARTING 3 CHARACTERS FROM STRING
SELECT RIGHT('SQL SERVER', 7)					-- REPORTS LAST 7 CHARACTERS FROM STRING
SELECT LTRIM ('  SQLSERVER')					-- TRUNCATE EXTRA SPACES BEFORE THE TEXT 
SELECT RTRIM ('SQLSERVER    ')					-- TRUNCATE EXTRA SPACES AFTER THE TEXT
SELECT CHARINDEX('D' , 'INDIGO MONTOYA');  		-- REPORT POSITION OF CHARACTER
SELECT STUFF('ABCDE', 3, 2, ' ')				-- FROM 3RD POSITION, REPLACE 2 CHARACTERS WITH SPACE
SELECT STUFF('SQLSERVER', 3, 1, 'L ')			-- FROM 3RD POSITION, REPLACE 1 CHARACTER WITH 'L '
SELECT VALUE FROM STRING_SPLIT('SQL SERVER T-SQL QUERIES', ' ');

--DATE FUNCTIONS
--DATEPART, DATENAME, DATEDIFF, DATEADD

SELECT GETDATE()
SELECT DATEPART(D,GETDATE())
SELECT DATEPART(DD,GETDATE())
SELECT DATEPART(DAY,GETDATE())
SELECT DATEPART(D,'12/23/2019')

SELECT DATEPART(D,GETDATE())
SELECT DATEPART(DD,GETDATE())
SELECT DATEPART(DAY,GETDATE())

SELECT DATEPART(M,GETDATE())
SELECT DATEPART(MM,GETDATE())
SELECT DATEPART(MONTH,GETDATE())

SELECT DATEPART(Y,GETDATE())
SELECT DATEPART(YEAR,GETDATE())
SELECT DATEPART(YYYY,GETDATE())

--DATENAME
SELECT DATENAME(DW,GETDATE())
SELECT DATENAME(DW,'3/22/2020')

SELECT DATENAME(MONTH,GETDATE())
SELECT DATENAME(MONTH,'12/23/2019')

--DATEDIFF
SELECT DATEDIFF(D,'12/23/2019','12/26/2019')
SELECT DATEDIFF(MONTH,'12/23/2019','4/26/2020')
SELECT DATEDIFF(YEAR,'12/23/2019','4/26/2024')

SELECT DATEDIFF(D,'12/29/2019','12/26/2019')

--DATEADD
SELECT DATEADD(D,10,GETDATE())
SELECT DATEADD(D,15,GETDATE())
SELECT DATEADD(MONTH,2,GETDATE())
SELECT DATEADD(YEAR,2,GETDATE())

SELECT DATEADD(D,-10,GETDATE())

--INTERVIEW QUESTION
--WRITE A QUERY TO GET THE MONTH START DATE VALUE AND MONTHEND DATE VALUE FOR THE GIVEN DATE
--MONTH START DATE
DECLARE @INPUT_DATE DATE
SET @INPUT_DATE='11/19/2019'
SELECT DATEPART(D,@INPUT_DATE)
SELECT DATEADD(D,-DATEPART(D,@INPUT_DATE)+1,@INPUT_DATE)

SELECT DATEADD(D,-23+1,@INPUT_DATE)

--MONTH END DATE
DECLARE @INPUT_DATE1 DATE
SET @INPUT_DATE1='2/19/2019'
SELECT EOMONTH(@INPUT_DATE1)
SELECT EOMONTH(@INPUT_DATE1,1)
SELECT EOMONTH(@INPUT_DATE1,2)

SELECT EMPID,EMPNAME,DATE_OF_JOIN,DATENAME(MONTH,DATE_OF_JOIN) AS DOJ_MONTHNAME FROM TBL_EMPL_MASTER

--STRING FUNCTIONS
--LEFT, RIGHT, LTRIM, RTRIM, LEN,DATALENGTH, REPLACE, SUBSTRING, STUFF, STR, CHARINDEX, PATINDEX, COALESCE, ISNULL

--LTRIM, RTRIM

SELECT EMPID,LTRIM(EMPNAME) AS EMP_NAME,AGE FROM TBL_EMPL_MASTER
SELECT RTRIM('   KRISHNA   ')--'   KRISHNA'
SELECT LTRIM('   KRISHNA   ')--'KRISHNA   '

SELECT RTRIM(LTRIM('   KRISHNA   '))--'KRISHNA'

--LEN,DATALENGTH
SELECT LEN('KRISHNA')--7
SELECT DATALENGTH('KRISHNA')--7

SELECT LEN('KRISHNA   ')--7
SELECT DATALENGTH('KRISHNA   ')--10

SELECT LEN('   KRISHNA')--10
SELECT DATALENGTH('   KRISHNA')--10

SELECT LEN('KRISHNA M')--9
SELECT DATALENGTH('KRISHNA M')--9

--REPLACE
SELECT REPLACE('SURESH','E',' AM ')
SELECT REPLACE('SURESH','E','')--SURSH'

--INTERVIEW QUESTION
--CAN YOU WRITE A QUERY TO GET THE NUMBER OF A LETTERS IN THE GIVEN STRING
DECLARE @INPUT_STR VARCHAR(200)
SET @INPUT_STR ='MICROSOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOFT'

SELECT DATALENGTH(@INPUT_STR) AS TOTAL_LENGTH --86
SELECT REPLACE(@INPUT_STR,'O','')
SELECT DATALENGTH(REPLACE(@INPUT_STR,'O',''))--7
SELECT DATALENGTH(@INPUT_STR)-DATALENGTH(REPLACE(@INPUT_STR,'O','')) AS CNT_OF_A_LETTERS

--LEFT, RIGHT
SELECT LEFT('RAM MOHAN',3)
SELECT RIGHT('SURESH RAO',3)
SELECT EMPID,EMPNAME,LEFT(EMPCITY,3) AS EMP_CITY_CODE FROM TBL_EMPL_MASTER

--SUBSTRING
SELECT SUBSTRING('KRISHNA MOHAN MACHARLA',9,5)
SELECT SUBSTRING('KRISHNA MOHAN MACHARLASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSNNN',9,500)

--
DECLARE @EMAIL_STRING VARCHAR(40)
SET @EMAIL_STRING='MARKMK123@SAMSUNG.COM'
SET @EMAIL_STRING='MARKMK123@HP.COM'

--STR (STRING)
--IF WE NEED TO CONVERT ANY INTEGERS TO STRING VALUES THEN WE WILL USE STR FUNCTION
SELECT STR(135,5)--'  135'
SELECT STR(135,4)--' 135'
SELECT REPLACE(STR(135,5),' ','A')

--INTERVIEW QUESTION
--HOW TO DISPLAY EMPLOYEE ID VALUES WITH UNIFORM LENGTH
SELECT * FROM DB_MOHAN.[dbo].[TBL_EMPLS_DATA]
SELECT LEN(MAX(EMPID))FROM DB_MOHAN.DBO.[TBL_EMPLS_DATA]
SELECT REPLACE(STR(EMPID,5),' ',0) AS EMPID,EMPNAME,SALARY FROM DB_MOHAN.[dbo].[TBL_EMPLS_SALARY]

--COALESCE
SELECT * FROM DB_MOHAN.DBO.TBL_PRODUCT_SALES
SELECT PRODUCTID,PRODUCTNAME, STATUS, COALESCE(DELIVERED_DATE,SHIPMENT_DATE,ORDERED_DATE,'1/1/1900') AS LATEST_STATUS_DATE 
FROM DB_MOHAN.DBO.TBL_PRODUCT_SALES

SELECT * FROM DB_MOHAN.DBO.TBL_PRODUCT_SALES

--ISNULL

SELECT 
EMPID,
EMPNAME,
ISNULL(MOBILENUMBER,0) AS MOB_NUMBER,
ISNULL(DATE_OF_JOIN,'1/1/1900') AS DOJ 
FROM TBL_EMPL_MASTER

SELECT 
EMPID,
EMPNAME,
COALESCE(MOBILENUMBER,AGE,EMPID,0) AS MOB_NUMBER,
COALESCE(DATE_OF_JOIN,'1/1/1900') AS DOJ 
FROM TBL_EMPL_MASTER

--CHARINDEX AND PATINDEX FUNCTIONS
--IF WE WANT TO FIND THE INDEX POSITION OF ANY CHARACTER THEN WE HAVE TO USE CHARINDEX FUNCTION OR PATINDEX FUNCTION

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN CHARINDEX AND PATINDEX
--1.USING CHARINDEX WE CAN FIND THE FIRST POSITION AND ALSO NEXT POSITIONS INDEXES OF ANY GIVEN CHARACTER
----BUT USING PATINDEX WE CAN FIND ONLY THE FIRST POSITION BUT NOT THE NEXT POSITIONS OF ANY GIVEN CHARACTER
--2. PATINDEX CAN RECOGNIZE THE WILD CHARACTERS (EX:[]) BUT CHARINDEX CAN NOT RECOGNIZE THE WILD CHARACTERS

SELECT CHARINDEX('A','KRISHNA MOHAN')
SELECT PATINDEX('%A%','KRISHNA MOHAN')

SELECT CHARINDEX('A','KRISHNA MOHAN')
SELECT CHARINDEX('A','KRISHNA MOHAN',7+1)

SELECT CHARINDEX('A','KRISHNA MOHAN',CHARINDEX('A','KRISHNA MOHAN')+1)
SELECT PATINDEX('%A%','KRISHNA MOHAN',7+1)

SELECT PATINDEX('%[E,K]%','RAJEEV KUMAR')
SELECT PATINDEX('%[E,K,A]%','RAJEEV KUMAR')

SELECT CHARINDEX('[E,K]','RAJEEV KUMAR')
SELECT CHARINDEX('[E,K]','RAJEEV [E,K] KUMAR')

--CAST AND CONVERT FUNCTIONS
--IF WE WANT TO CHANGE THE METADATE (I.E. DATATYPES) OF ANY GIVEN VALUE 
---FROM ONE FORMAT TO ANOTHER FORMAT THEN WE HAVE TO USE CAST AND CONVERT FUNCTIONS

SELECT GETDATE()
SELECT CAST(GETDATE() AS DATE)
SELECT CAST(GETDATE() AS VARCHAR(20))

SELECT CONVERT(DATE,GETDATE())
SELECT CONVERT(VARCHAR(20),GETDATE())

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN CAST AND CONVERT FUNCTION
--USING CAST FUNCTION WE CAN DISPLAY DATE VALUE IN TWO DIFFERENT STYLES
--BUT USING CONVERT FUNCTION WE CAN DISPAY DATE VALUE IN 15 DIFFERENT STYLES

SELECT CONVERT(VARCHAR(20),GETDATE())
SELECT CONVERT(VARCHAR(20),GETDATE(),100)
SELECT CONVERT(VARCHAR(20),GETDATE(),101)
SELECT CONVERT(VARCHAR(20),GETDATE(),102)
SELECT CONVERT(VARCHAR(20),GETDATE(),103)
SELECT CONVERT(VARCHAR(20),GETDATE(),104)
SELECT CONVERT(VARCHAR(20),GETDATE(),105)
SELECT CONVERT(VARCHAR(20),GETDATE(),106)
SELECT CONVERT(VARCHAR(20),GETDATE(),107)
SELECT CONVERT(VARCHAR(20),GETDATE(),108)
SELECT CONVERT(VARCHAR(20),GETDATE(),109)
SELECT CONVERT(VARCHAR(20),GETDATE(),110)
SELECT CONVERT(VARCHAR(20),GETDATE(),111)
SELECT CONVERT(VARCHAR(20),GETDATE(),112)
SELECT CONVERT(VARCHAR(20),GETDATE(),113)
SELECT CONVERT(VARCHAR(20),GETDATE(),114)
SELECT CONVERT(VARCHAR(20),GETDATE(),115)

-- RANK FUNCTIONS	:	 USED TO GENERATE SEQUENCE OF VALUES.
-- HOW TO GENERATE SEQUENCE VALUES FOR EXISTING TABLE DATA? USING "SET" FUNCTIONS

SELECT *, ROW_NUMBER() OVER (ORDER BY MEASURE) AS SEQ1 FROM TBLINVENTORY

SELECT *, RANK() OVER (ORDER BY MEASURE) AS SEQ2 FROM TBLINVENTORY
SELECT *, DENSE_RANK() OVER (ORDER BY MEASURE) AS SEQ3 FROM TBLINVENTORY

SELECT *,	ROW_NUMBER() OVER (ORDER BY MEASURE) AS SEQ1,	-- UNIQUE SEQUENCE
			RANK() OVER (ORDER BY MEASURE) AS SEQ2,			-- SAME VALUE HAS SAME SEQUENCE. NEW SEQUENCE ON ROW NUMBER
			DENSE_RANK() OVER (ORDER BY MEASURE) AS SEQ3,	-- SAME VALUE HAS SAME SEQUENCE. NEW SEQUENCE ON PREV. SEQUENCE
			ROW_NUMBER() OVER (PARTITION BY MEASURE ORDER BY MEASURE) AS SEQ4	-- RESET IN SEQUENCE FOR EVERY VALUE
FROM TBLINVENTORY

-- A BANKING ENVIRONMENT.		

	CREDITS		:		C1, C2, C3.....			
	DEBITS		:		D1, D2, D3, D4....
	TRANSACTIONS:		T1, T2, T3, T4, T5........................	:	ROW_NUMBER()
	CREDITS		:		C1 C1 C1 C1..... 		D2  D2  D2  D3 ....	:	DENSE_RANK()
	CREDITS		:		C1 C2 C3 C4.....		D1  D2  D3  D4 .... :	PARTITION BY


--RANK FUNCTIONS
--ROWNUMBER,RANK,DENSE_RANK,NTILE FUNCTION

SELECT * FROM TBL_EMPL_MASTER ORDER BY SALARY DESC

SELECT EMPID,EMPNAME,SALARY,ROW_NUMBER()OVER(ORDER BY SALARY DESC) AS ROW_NUM FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY,RANK()OVER(ORDER BY SALARY DESC) AS RANK_NUM FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY,DENSE_RANK()OVER(ORDER BY SALARY DESC) AS RANK_NUM FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY,NTILE(3)OVER(ORDER BY SALARY DESC) AS RANK_NUM FROM TBL_EMPL_MASTER

SELECT EMPID,EMPNAME,EMPCITY,SALARY,
		DENSE_RANK()OVER(PARTITION BY EMPCITY ORDER BY SALARY DESC) AS RANK_NUM FROM TBL_EMPL_MASTER


--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN THE RANK AND DENSE RANK
--FOR THE SAME SALARIED PERSONS, THE RANK WILL SHARE THE SAME RANK, 
--BUT IT WILL SKIP THE NEXT RANK COMING IN THE SEQUENCE
--BUT THE DENSE_RANK FUNCTION,WILL SHARE SAME RANK FOR THE SAME SALARY VALUES BUT IT WONT SKIP THE NEXT RANK 

--ANALYTICAL FUNCTIONS/ WINDOW FUNCTIONS
--LEAD,LAG, FIRST_VALUE, LAST_VALUE, RUNNING TOTAL

SELECT EMPID,EMPNAME,SALARY FROM TBL_EMPL_MASTER ORDER BY SALARY DESC
--LEAD
--IT WILL SHOW THE NEXT VALUE DATA COMING IN THE SEQUENCE LIST
SELECT EMPID,EMPNAME,SALARY, LEAD(SALARY)OVER(ORDER BY SALARY DESC) AS LEAD_VAL FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY, LEAD(SALARY,2,0)OVER(ORDER BY SALARY DESC) AS LEAD_VAL FROM TBL_EMPL_MASTER

--LAG
--IT WILL SHOW THE PREVIOUS VALUE DATA COMING IN THE SEQUENCE LIST
SELECT EMPID,EMPNAME,SALARY, LAG(SALARY)OVER(ORDER BY SALARY DESC) AS PREVIOUS_VAL FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY, LAG(SALARY,2,-1)OVER(ORDER BY SALARY DESC) AS PREVIOUS_VAL FROM TBL_EMPL_MASTER

--FIRST VALUE
SELECT EMPID,EMPNAME,SALARY,FIRST_VALUE(SALARY)OVER(ORDER BY SALARY DESC) AS FIRST_VAL FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,EMPCITY,SALARY,FIRST_VALUE(SALARY)OVER(PARTITION BY EMPCITY ORDER BY SALARY DESC) AS FIRST_VAL FROM TBL_EMPL_MASTER

--LAST_VALUE
SELECT EMPID,EMPNAME,SALARY,
		LAST_VALUE(SALARY)OVER(ORDER BY SALARY DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LEAST_SAL_VAL 
FROM TBL_EMPL_MASTER

SELECT EMPID,EMPNAME,EMPCITY,SALARY,
		LAST_VALUE(SALARY)OVER(PARTITION BY EMPCITY ORDER BY SALARY DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LEAST_SAL_VAL 
FROM TBL_EMPL_MASTER

--CUMULATIVE SUM / RUNNING TOTAL
SELECT EMPID,EMPNAME,SALARY, SUM(SALARY)OVER(ORDER BY SALARY ASC) AS RUNNING_TOTAL FROM TBL_EMPL_MASTER
SELECT EMPID,EMPNAME,SALARY, 
	SUM(SALARY)OVER(ORDER BY SALARY ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RUNNING_TOTAL 
FROM TBL_EMPL_MASTER

--CASE STATEMENT
SELECT EMPID,EMPNAME,SALARY, 
		CASE WHEN SALARY <=25000 THEN 'SOFTWARE ENGG'
			 WHEN SALARY >25000 AND SALARY <=50000 THEN 'SENIOR SOFTWARE ENGG'
			 WHEN SALARY>50000 AND SALARY<100000 THEN 'TEAM LEAD'
			ELSE 'MANAGER'
		END AS 'DESG'
FROM TBL_EMPL_MASTER

--NUMERIC FUNCTIONS
--ABSOLUTE, LOG, LOG10, POWER, ROUND, SQUARE ROOT,CEILING, FLOOR

SELECT ABS(-4)
SELECT LOG(1000)
SELECT LOG10(1000)
SELECT POWER(2,3)
SELECT SQRT(9)
SELECT ROUND(123.456,2)
SELECT ROUND(123.456,1)
SELECT CEILING(123.2)
SELECT FLOOR(123.7)

--VIEWS
--VIEW IS A VIRTUAL TABLE
--ANY VALID SQL SELECT QUERY CAN BECOME A VIEW
--REUSABILITY OF THE SELECT QUERIES, WE CAN WRITE/ STORE THE QUERY INSIDE A VIEW AND WE CAN REUSE IT
--VIEWS ARE USED TO RESOLVE THE SECURITY ISSUES
--VIEWS ARE USED TO REDUCE THE NETWORK TRAFFIC

CREATE VIEW VW_EMPLS_INFO
AS
SELECT		EMP.EMPID,EMP.EMPNAME,EMP.DATE_OF_JOIN,EMP.DESIGNATION,EMP.EMPCITY
			,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS
FROM		TBL_EMPL_MASTER EMP
LEFT JOIN	TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID
LEFT JOIN	TBL_EMPLS_BANK_DETAILS BNK ON BNK.EMPID=EMP.EMPID

SELECT * FROM VW_EMPLS_INFO

--ALTER THE VIEW
ALTER VIEW VW_EMPLS_INFO
AS
SELECT		EMP.EMPID,EMP.EMPNAME,EMP.DATE_OF_JOIN,EMP.DESIGNATION,EMP.EMPCITY
			,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS
			,ADR.ADDRESS_TYPE,ADR.EMPSTATE
FROM		TBL_EMPL_MASTER EMP
LEFT JOIN	TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID
LEFT JOIN	TBL_EMPLS_BANK_DETAILS BNK ON BNK.EMPID=EMP.EMPID
LEFT JOIN   TBL_EMPLOY_ADDRESS ADR ON ADR.EMPID=EMP.EMPID

SELECT * FROM TBL_EMPL_MASTER

CREATE VIEW VW_EMPLS_MASTER_DATA
AS
SELECT EMPID,EMPNAME,DESIGNATION,DATE_OF_JOIN,EMPCITY,DEPTID  FROM TBL_EMPL_MASTER

SELECT * FROM VW_EMPLS_MASTER_DATA


SELECT  PROF.EMPID,PROF.EMPNAME,PROF.DATE_OF_JOIN,
		V_EMP.ADDRESS_TYPE,V_EMP.LEAVE_FROM
FROM TBL_EMPL_PROFILE PROF
LEFT JOIN VW_EMPLS_INFO V_EMP ON PROF.EMPID=V_EMP.EMPID

UPDATE VW_EMPLS_MASTER_DATA SET DATE_OF_JOIN='12/20/2010' WHERE EMPID=1

SELECT * FROM VW_EMPLS_MASTER_DATA
SELECT * FROM TBL_EMPL_MASTER

DELETE FROM VW_EMPLS_MASTER_DATA WHERE EMPID=20

SELECT * FROM VW_EMPLS_INFO
UPDATE VW_EMPLS_INFO SET DESIGNATION='MANAGER' WHERE EMPID=1
UPDATE VW_EMPLS_INFO SET DESIGNATION='SENIOR MANAGER',LEAVE_FROM='11/20/2019' WHERE EMPID=1

CREATE INDEX IND1 ON TBL_EMPL_MASTER(EMPID)
CREATE INDEX IND_V ON VW_EMPLS_MASTER_DATA(EMPID)

UPDATE TBL_EMPL_MASTER SET EMPID=12 WHERE EMPID=20 AND EMPCITY='MUMBAI'
SP_HELPINDEX TBL_EMPL_MASTER
DROP INDEX INDV ON VW_EMPLS_DATA

CREATE VIEW VW_EMPLS_DATA WITH SCHEMABINDING
AS
SELECT EMPID,EMPNAME,EMPCITY,DATE_OF_JOIN,DESIGNATION,GENDER FROM DBO.TBL_EMPL_MASTER

CREATE UNIQUE CLUSTERED INDEX INDV ON VW_EMPLS_DATA(EMPID)
CREATE INDEX INDV2 ON VW_EMPLS_DATA(EMPCITY)
SP_HELPINDEX VW_EMPLS_DATA

--IN-ORDER TO CREATE INDEX ON A VIEW
--1. THE VIEW SHOULD CREATE WITH "WITH SCHEMABINDING" OPTION
--2. WE CAN NOT USE "*" IN THE SELECT LIST, WE SHOULD REPLACE WITH COLUMN NAMES
--3. WE SHOULD REFER THE TABLE NAMES ALONG WITH THE SCHEMA NAME EX: DBO.TBL_EMPL_MASTER
--4. WE CAN NOT CREATE A NON CLUSTERED INDEX DIRECTLY ON  A VIEW, FIRST WE SHOULD CREATE UNIQUE CLUSTERED INDEX AND THEN THE NONCLUSTERED INDEX
--5. WE SHOULD REMOVE DUPLICATE ENTRIES FROM THE SOURCE TABLE, BEFORE CREATING THE INDEX

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=20

UPDATE VW_EMPLS_DATA SET EMPID=12 WHERE EMPID=20 AND EMPCITY='MUMBAI'

-- ITEM #1. HOW TO CREATE SCHEMAS IN A DATABASE ? LIKE A FODLER IN OS DRIVE
CREATE SCHEMA SCHEMA1

CREATE SCHEMA SCHEMA2

-- ITEM #2. HOW TO CREATE THE TABLES USING THE SCHEMAS ?
CREATE TABLE SCHEMA1.TABLE1 (COL1 INT, COL2 INT)
CREATE TABLE SCHEMA1.TABLE2 (COL1 INT, COL2 INT)

-- ITEM #3: HOW TO STORE DATA INTO THE ABOVE TABLES ?
INSERT INTO SCHEMA1.TABLE1 VALUES (1,1), (2,2), (3,3)

-- ITEM #4: HOW TO REPORT DATA FROM ABOVE TABLES ?
SELECT * FROM TABLE1  -- ERROR									-- 1 PART NAMING CONVENTION
SELECT * FROM SCHEMA1.TABLE1									-- 2 PART NAMING CONVENTION
SELECT * FROM UNIVERSITYDATABASE.SCHEMA1.TABLE1					-- 3 PART NAMING CONVENTION

-- ITEM #5: HOW TO MOVE (MIGRATE) A TABLE FROM ONE SCHEMA TO ANOTHER ?
ALTER SCHEMA SCHEMA2 TRANSFER SCHEMA1.TABLE1

SELECT * FROM #TABLE1							-- ERROR. REASON : LOCAL TEMPORARY TABLE
SELECT * FROM ##TABLE2							-- NO ERROR. GLOBALLY ACCESSIBLE. ACROSS SERVER. 


--SCHEMA
--SCHEMA PROVIDES FIRST LEVEL OF SECURITY TO THE TABLE DATA

CREATE TABLE TBL_EMPLS_DETAILS (EMPID INT,EMPNAME VARCHAR(30),SALARY INT)
INSERT INTO TBL_EMPLS_DETAILS VALUES (1,'KRISHNA',300000)
INSERT INTO TBL_EMPLS_DETAILS VALUES (2,'KRISHNA',300000)
INSERT INTO TBL_EMPLS_DETAILS VALUES (3,'KRISHNA',300000)

CREATE SCHEMA HR_DEPT
CREATE TABLE HR_DEPT.TBL_EMPLS_SALARY_INFO (EMPID INT, PROJECT_NAME VARCHAR(30), SALARY INT, IS_BILLABLE BIT)

INSERT INTO HR_DEPT.TBL_EMPLS_SALARY_INFO VALUES (1,'PROCUREMENT',300000,1)
INSERT INTO HR_DEPT.TBL_EMPLS_SALARY_INFO VALUES (2,'PROCUREMENT',400000,1)
INSERT INTO HR_DEPT.TBL_EMPLS_SALARY_INFO VALUES (3,'PROCUREMENT',500000,1)

SELECT * FROM HR_DEPT.TBL_EMPLS_SALARY_INFO

ALTER SCHEMA HR_DEPT TRANSFER DBO.TBL_EMPLS_DETAILS


SELECT * FROM TBL_EMPLS_DETAILS
SELECT * FROM HR_DEPT.TBL_EMPLS_DETAILS

--HOW TO ADD A NEW COLUMN FOR AN EXISTING TABLE
SP_HELP TBL_EMPLOY_MASTER

SELECT EMPID,EMPNAME,EMPSTATE,EMPCITY,EMPADDRESS FROM TBL_EMPLOY_MASTER
SELECT * FROM TBL_EMPLOY_MASTER

ALTER TABLE TBL_EMPLOY_MASTER ADD EMPCITY VARCHAR(30)
ALTER TABLE TBL_EMPLOY_MASTER ADD EMPSTATE VARCHAR(30), SALARY INT

ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPNAME VARCHAR(50)
ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPNAME INT
ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPCITY INT
ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPID VARCHAR(10)---(STRING, INT , SPECIAL CHARACTERS)
ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPID INT

ALTER TABLE TBL_EMPLOY_MASTER DROP COLUMN EMPSTATE,SALARY
ALTER TABLE TBL_EMPLOY_MASTER DROP COLUMN EMPCITY

--ADDING A PRIMARY KEY ON AN EXISTING TABLE
ALTER TABLE TBL_EMPLOY_MASTER ADD PRIMARY KEY (EMPID)

ALTER TABLE TBL_EMPLOY_MASTER ALTER COLUMN EMPID INT NOT NULL

---CTE TABLE TO REMOVE DUPLICATES
WITH CTE_DUP_TBL
AS
(SELECT *,ROW_NUMBER()OVER (PARTITION BY EMPID ORDER BY EMPID ASC) AS R_NO FROM TBL_EMPLOY_MASTER ) 
SELECT * FROM CTE_DUP_TBL WHERE R_NO>1
DELETE FROM CTE_DUP_TBL WHERE R_NO>1

SELECT * FROM TBL_EMPLOY_MASTER

BEGIN TRANSACTION
DELETE FROM TBL_EMPLOY_MASTER
ROLLBACK


SP_HELP TBL_EMPLOY_MASTER
CREATE TABLE TBL_EMPL_LEAVE_DETAILS (EMPID INT, LEAVE_FROM DATE, LEAVE_UPTO DATE, NO_OF_DAYS INT)
INSERT INTO TBL_EMPL_LEAVE_DETAILS VALUES (1,'12/20/2013','12/26/2013',6)
INSERT INTO TBL_EMPL_LEAVE_DETAILS VALUES (2,'12/20/2013','12/26/2013',6)
INSERT INTO TBL_EMPL_LEAVE_DETAILS VALUES (3,'12/20/2013','12/26/2013',6)
INSERT INTO TBL_EMPL_LEAVE_DETAILS VALUES (10,'12/20/2013','12/26/2013',6)

--HOW TO CREATE FOREIGN KEY CONSTRAINT ON AN EXISTING TABLE
ALTER TABLE TBL_EMPL_LEAVE_DETAILS ADD FOREIGN KEY (EMPID) REFERENCES TBL_EMPLOY_MASTER(EMPID)

--HOW TO CREATE IDENTITY SEED FOR  A TABLE
CREATE TABLE TBL_EMPLS_IDENT (EMPID INT IDENTITY(1,1), EMPNAME VARCHAR(30), SALARY INT, AGE INT)
INSERT INTO TBL_EMPLS_IDENT VALUES ('KRISHNA',300000,35)
INSERT INTO TBL_EMPLS_IDENT VALUES ('MOHAN',400000,35)
INSERT INTO TBL_EMPLS_IDENT VALUES ('KALYAN',500000,35)
INSERT INTO TBL_EMPLS_IDENT VALUES ('RAMESH',600000,35)
SELECT * FROM TBL_EMPLS_IDENT

SET  IDENTITY_INSERT [TBL_EMPLS_IDENT] ON
INSERT INTO TBL_EMPLS_IDENT(EMPID,EMPNAME,SALARY,AGE) VALUES (5,'SURESH',600000,35)

SET  IDENTITY_INSERT [TBL_EMPLS_IDENT] OFF
INSERT INTO TBL_EMPLS_IDENT VALUES ('MAHESH',600000,35)

SP_HELP TBL_EMPLS_IDENT

--INTERVIEW QUESTION
--WITH OUT IMPOSING IDENTITY SEED PROPERTY ON A COLUMN, CAN WE AUTO POPULATE THE COLUMN DATA ,
--YES, BY USING SEQUENCE GENERATOR WE CAN AUTOPOPULATE ANY COLUMN DATA

CREATE TABLE TBL_EMPLS_SEQ (EMPID INT, EMPNAME VARCHAR(30),SALARY INT)

CREATE SEQUENCE SQ_EMPID
START WITH 1
INCREMENT BY 1

INSERT INTO TBL_EMPLS_SEQ VALUES (NEXT VALUE FOR SQ_EMPID, 'KRISHNA',400000)
INSERT INTO TBL_EMPLS_SEQ VALUES (NEXT VALUE FOR SQ_EMPID, 'MOHAN',500000)
INSERT INTO TBL_EMPLS_SEQ VALUES (NEXT VALUE FOR SQ_EMPID, 'AMAN',600000)
INSERT INTO TBL_EMPLS_SEQ VALUES (NEXT VALUE FOR SQ_EMPID, 'RAKESH',700000)

SELECT * FROM TBL_EMPLS_SEQ



/*
TEMPORARY TABLE:
	ALSO CALLED "TEMP TABLES"
	THESE ARE USED TO STORE TABLES ON A TEMPORARY BASIS. 

	THESE TEMPORARY TABLES ARE AUTO STORED IN "TEMPDB".
	TEMPDB IS ONE OF THE SYSTEM DATABASE.

TYPES OF TEMPORARY TABLES:
	1. LOCAL TEMPORARY TABLES	:	
		ACCESSIBLE WITHIN THE SESSION (QUERY WINDOW)		
		# PREFIX

	2. GLOBAL TEMPORARY TABLES	:	
		ACCESSIBLE WITHIN THE CONNECTION (ALL QUERY WINDOWS)	
		## PREFIX
*/

CREATE TABLE #TABLE1 (COL1 INT, COL2 INT)			-- THIS IS A LOCAL  TEMPORARY TABLE
INSERT INTO #TABLE1 VALUES (1,1), (2,2), (3,3)
SELECT * FROM #TABLE1


CREATE TABLE ##TABLE2 (COL1 INT, COL2 INT)			-- THIS IS A GLOBAL TEMPORARY TABLE
INSERT INTO ##TABLE2 VALUES (100,100), (200,200), (300,300)
SELECT * FROM ##TABLE2

SELECT * FROM #TABLE1
SELECT * FROM ##TABLE2


--FROM OTHER QUERY WINDOW :
SELECT * FROM #TABLE1					-- ERROR
SELECT * FROM ##TABLE2					-- WORKS


--TEMPORARY TABLES
--IF WE WANT TO STORE ANY QUERY OUTPUT TEMPORARLY THEN WE NEED TO GO FOR TEMP TABLES
--LOCAL TEMP TABLE, GLOBAL TEMP TABLE, TABLE VARIABLE, CTE TABLE


SELECT		EMP.EMPID,EMP.EMPNAME,EMP.DATE_OF_JOIN,EMP.DESIGNATION,EMP.EMPCITY
			,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS
			,ADR.ADDRESS_TYPE,ADR.EMPSTATE
INTO        #EMP_DETAILS_TEMP
FROM		TBL_EMPL_MASTER EMP
LEFT JOIN	TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID
LEFT JOIN	TBL_EMPLS_BANK_DETAILS BNK ON BNK.EMPID=EMP.EMPID
LEFT JOIN   TBL_EMPLOY_ADDRESS ADR ON ADR.EMPID=EMP.EMPID

SELECT * FROM #EMP_DETAILS_TEMP

CREATE TABLE #TBL_EMP_DETAILS (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)

INSERT INTO #TBL_EMP_DETAILS
SELECT EMPID,EMPNAME,SALARY,AGE FROM TBL_EMPL_MASTER

/*
CTE		:	 COMMON TABLE EXPRESSION
			 USED TO STORE THE QUERY AND ITS RESULT IN MEMORY.
			 FOR FASTER DATA ACCESS AND FASTER DML OPERATIONS.

REAL-WORLD USE:	CTES ARE USED TO AVOID SELF JOINS AND SUB QUERIES.
*/
-- EXAMPLE 1:
WITH CTE
AS
(
SELECT * FROM TBLTEST			-- PHASE 1:		THIS QUERY OUTPUT IS STORED IN MEMORY
)
SELECT * FROM CTE				-- PHASE 2:		WE ARE READING FROM THIS MEMORY COPY

-- EXAMPLE 2:
WITH CTE
AS
(
SELECT * FROM TBLTEST
)
INSERT INTO CTE VALUES (77,77,77)		-- INSTEAD OF INSERTING INTO TABLE, WE ARE INSERTING INTO CTE		

-- REQ : HOW TO UPDATE RANK_COL WITH UNIQUE SEQUENCE VALUES?

SELECT *, ROW_NUMBER() OVER (ORDER BY VALUE_COL) AS SEQUENCE FROM TBLTEST


UPDATE TBLTEST 
SET RANK_COL = SUBQUERY.SEQUENCE
FROM
(
SELECT *, ROW_NUMBER() OVER (ORDER BY VALUE_COL) AS SEQUENCE FROM TBLTEST
) AS SUBQUERY
INNER JOIN TBLTEST
ON
SUBQUERY.ID_COL = TBLTEST.ID_COL AND SUBQUERY.VALUE_COL = TBLTEST.VALUE_COL

-- QUERY AVOIDING SELF JOINS & SUB QUERIES:
WITH CTE 
AS
(
SELECT *, ROW_NUMBER() OVER (ORDER BY VALUE_COL) AS SEQUENCE FROM TBLTEST
)
UPDATE CTE SET RANK_COL = SEQUENCE;
SELECT * FROM TBLTEST

-- RECURSION :  A MECHANISM TO CALL AN OBJECT INSIDE ITSELF.
-- RECURSIVE CTE : A CTE CALLS THE SAME CTE INSIDE IT.
-- EVERY CTE HAS AN "ANCHOR" ELEMENT TO START THE LOOP. AND A "TERMINATION" CONDITION.

SELECT DATENAME(DW,0)		--	DW : DAY OF THE WEEK
SELECT DATENAME(DW,1)	
SELECT DATENAME(DW,2)

SELECT DATENAME(DW,1)	
UNION ALL
SELECT DATENAME(DW,2)

WITH CTE  (N, WEEKDAY)
AS
(
SELECT 0, DATENAME(DW, 0)					-- ANCHOR ELEMENT
UNION ALL
SELECT N+1, DATENAME(DW, N+1) FROM CTE		--LOOP
WHERE
N <= 5										--TERMINATION				
)
SELECT * FROM CTE 	

;WITH CTE (N, WEEKDAYNAME,MONTHNAMES)
AS
(
SELECT 0, DATENAME(DW,0),DATENAME(D,0)
UNION ALL
SELECT N+1, DATENAME(DW,N+1),DATENAME(D,N+1) FROM CTE WHERE N <=5
) 
SELECT * FROM CTE 

--LOCAL TEMP TABLE
--1. THE SCOPE OF THE LOCAL TEMP TABLE IS LIMITED TO THE CURRENT QUERY SESSION WINDOW
--2. NO OTHER USERS CAN ACCESS LOCAL TEMP TABLE, AND THE CURRENT USER ALSO CAN ACCESS FROM THE CURRENT SESSION ONLY

CREATE TABLE #TBL_EMP_LEV_DETAILS (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE)

INSERT INTO #TBL_EMP_LEV_DETAILS
SELECT EMP.EMPID,EMPNAME,SALARY,AGE,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPL_MASTER EMP LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV 
ON EMP.EMPID=LEV.EMPID

SELECT * FROM #TBL_EMP_LEV_DETAILS

--GLOBAL TEMP TABLE
--1. THE SCOPE OF THE GLOBAL TEMP TABLE IS LIMITED TO THE CURRENT QUERY SESSION WINDOW AS WELL AS OTHER SESSIONS ALSO
--2. THE OTHER USERS CAN ALSO ACCESS THE GLOBAL TEMP TABLE
CREATE TABLE ##TBL_EMP_LEV_DETAILS_GLB (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE)

INSERT INTO ##TBL_EMP_LEV_DETAILS_GLB
SELECT EMP.EMPID,EMPNAME,SALARY,AGE,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPL_MASTER EMP LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV 
ON EMP.EMPID=LEV.EMPID

SELECT * FROM ##TBL_EMP_LEV_DETAILS_GLB

--THE TEMPORARY TABLES WILL BE STORED IN TEMPDB DATABASE IN THAT UNDER TEMPORARY TABLES FOLDER
--THE LIFE SPAN OF THE TEMPORARY TABLES, ONCE THE USER CLOSES THE QUERY SESSION IN WHICH HE CREATED THE TABLES, THEN AUTOMATICALLY
--THE TEMP TABLES WILL GET DROPPED OFF OR IF THE USER LOGOFF FROM THE SERVER THEN ALSO THE TABLES WILL GET DROPPED

DECLARE @TODAYSDATE DATE, @NAME VARCHAR(30)
SET @TODAYSDATE=GETDATE()
SET @NAME='KRISHNA MOHAN'

SELECT @TODAYSDATE,@NAME

--DECLARE @TBL_EMP_VAR TABLE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)

--INSERT INTO @TBL_EMP_VAR VALUES (1,'RAMESH',300000,34)
--INSERT INTO @TBL_EMP_VAR VALUES (2,'SURESH',300000,34)
--INSERT INTO @TBL_EMP_VAR VALUES (3,'VARMA',300000,34)

SELECT * FROM @TBL_EMP_VAR

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN TEMPORARY TABLE AND A TABLE VARIABLE
--1. SCOPE: THE SCOPE OF THE TEMPORARY TABLE IS LIMITED TO THE CURRENT SESSION BUT THE SCOPE OF THE TABLE VARIABLE IS LIMITED TO QUERY WE ARE EXECUTING
--WE CAN ACCESS TEMPORARY TABLES FROM THE PARENT PROCEDURES AS WELL AS FROM THE CHILD PROCEDURES, BUT WE CAN ACCESS TABLE VARIABLES ONLY FROM PARENT PROCEDURE BUT NOT FROM CHILD PROCEDURE

--2. INDEX: WE CAN CREATE INDEXES ON A TEMPORARY TABLE BUT NOT ON TABLE VARIABLES
--3. ROLLBACK COMMAND: WE CAN ROLLBACK THE DATA FROM A TEMPORARY TABLE BUT NOT FROM TABLE VARIABLE
--4. STORAGE: THE TEMPORARY TABLES WILL BE STORED IN THE TEMPDB DATABASE, THE TABLE VARIABLES WONT STORE IN TEMPDB DATABASE, THEY ARE STORED IN SQL SERVER CACHE MEMORY
--5. TEMPORARY TABLES ARE USED TO STORE HIGH VOLUME OF DATA, AND TABLE VARIABLES ARE USED TO STORE SMALL AMOUNT OF DATA



CREATE PROCEDURE USP_PARENT
AS
BEGIN

CREATE TABLE #TBL_EMP_LEV_SP (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE)

INSERT INTO #TBL_EMP_LEV_SP
SELECT EMP.EMPID,EMPNAME,SALARY,AGE,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPL_MASTER EMP LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV 
ON EMP.EMPID=LEV.EMPID

EXEC USP_CHILD

SELECT * FROM #TBL_EMP_LEV_SP

END

--CHILD PROCEDURE
CREATE PROCEDURE USP_CHILD
AS
BEGIN

SELECT T.*,BNK.* FROM #TBL_EMP_LEV_SP T LEFT JOIN TBL_EMPLS_BANK_DETAILS BNK ON T.EMPID=BNK.EMPID
END


--EXEC PARENT PROCEDURE
EXEC USP_PARENT

--PROCEDURES FOR TABLE VARIABLE 
CREATE PROCEDURE USP_PARENT_VAR
AS
BEGIN
DECLARE @TBL_EMP_VAR_PARENT TABLE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)

INSERT INTO @TBL_EMP_VAR_PARENT VALUES (1,'RAMESH',300000,34)
INSERT INTO @TBL_EMP_VAR_PARENT VALUES (2,'SURESH',300000,34)
INSERT INTO @TBL_EMP_VAR_PARENT VALUES (3,'VARMA',300000,34)

EXEC USP_CHILD_VAR
SELECT * FROM @TBL_EMP_VAR_PARENT
END

--
CREATE PROCEDURE USP_CHILD_VAR
AS
BEGIN
DECLARE @TBL_EMP_VAR_PARENT TABLE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)
SELECT * FROM @TBL_EMP_VAR_PARENT T LEFT JOIN TBL_EMPLS_BANK_DETAILS BNK ON T.EMPID=BNK.EMPID
END

EXEC USP_PARENT_VAR

--INDEXES ON TEMP TABLES
CREATE TABLE #TBL_EMP_LEV_IND (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE)

INSERT INTO #TBL_EMP_LEV_IND
SELECT EMP.EMPID,EMPNAME,SALARY,AGE,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPL_MASTER EMP LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV 
ON EMP.EMPID=LEV.EMPID 

SELECT * FROM #TBL_EMP_LEV_IND

CREATE INDEX IND1 ON #TBL_EMP_LEV_IND(EMPID)

DECLARE @TBL_EMP_VAR_IND TABLE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)

INSERT INTO @TBL_EMP_VAR_IND VALUES (1,'RAMESH',300000,34)
INSERT INTO @TBL_EMP_VAR_IND VALUES (2,'SURESH',300000,34)
INSERT INTO @TBL_EMP_VAR_IND VALUES (3,'VARMA',300000,34)

SELECT * FROM @TBL_EMP_VAR_IND

CREATE INDEX IND2 ON @TBL_EMP_VAR_IND(EMPID)

--APPLYING ROLLBACK ON TEMP TABLES

SELECT * FROM #TBL_EMP_LEV_IND

BEGIN TRAN
DELETE FROM #TBL_EMP_LEV_IND
ROLLBACK

DECLARE @TBL_EMP_VAR_ROLLBK TABLE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT)

INSERT INTO @TBL_EMP_VAR_ROLLBK VALUES (1,'RAMESH',300000,34)
INSERT INTO @TBL_EMP_VAR_ROLLBK VALUES (2,'SURESH',300000,34)
INSERT INTO @TBL_EMP_VAR_ROLLBK VALUES (3,'VARMA',300000,34)

SELECT * FROM @TBL_EMP_VAR_ROLLBK--3 RECORDS


BEGIN TRAN
DELETE FROM @TBL_EMP_VAR_ROLLBK
ROLLBACK

SELECT * FROM @TBL_EMP_VAR_ROLLBK

DROP TABLE IF EXISTS #TBL_EMP_LEV_IND

CREATE TABLE #TBL_EMP_LEV_IND (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE)

INSERT INTO #TBL_EMP_LEV_IND
SELECT EMP.EMPID,EMPNAME,SALARY,AGE,LEAVE_FROM,LEAVE_UPTO FROM TBL_EMPL_MASTER EMP LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV 
ON EMP.EMPID=LEV.EMPID 

SELECT * FROM #TBL_EMP_LEV_IND

DROP TABLE IF EXISTS #TBL_EMP_LEV_IND

IF OBJECT_ID('TEMPDB..#TBL_EMP_LEV_IND')<0
BEGIN 
DROP TABLE #TBL_EMP_LEV_IND
END

USE TEMPDB
SELECT * FROM SYS.OBJECTS WHERE NAME LIKE '%#TBL_EMP_LEV_IND%'

SP_HELPINDEX 


--CTE TABLES (COMMON TABLE EXPRESSIONS)

WITH CTE_EMP
AS
(
SELECT EMP.EMPID,EMP.EMPNAME,EMP.DESIGNATION
		,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS,
		BNK.ACCOUNT_NO,BNK.BRANCH_NAME,BNK.BANK_NAME
FROM TBL_EMPL_MASTER EMP
LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID
LEFT JOIN TBL_EMPLS_BANK_DETAILS BNK ON BNK.EMPID=EMP.EMPID
)

SELECT * FROM CTE_EMP;

CREATE VIEW VW_EMP
AS
WITH CTE_EMP_DATA
AS
(SELECT EMP.EMPID,EMP.EMPNAME,EMP.DESIGNATION
		,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS
FROM TBL_EMPL_MASTER EMP
LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID )

SELECT CT.*,BNK.ACCOUNT_NO,BNK.BRANCH_NAME
FROM CTE_EMP_DATA CT LEFT JOIN TBL_EMPLS_BANK_DETAILS BNK ON CT.EMPID=BNK.EMPID


-- TASK 1: HOW TO REPORT LIST OF ALL EMPLOYEES WITH MAXIMUM SALARY?
SELECT * FROM EMPLOYEE_INFO WHERE EMP_SAL=(SELECT MAX(EMP_SAL) FROM EMPLOYEE_INFO)


--SUB QUERY
--A QUERY INSIDE ANOTHER QUERY IS CALLED AS A SUB QUERY
--IN CASE OF SUB QUERY THE INNER QUERY WILL EXECUTE FIRST AND THEN THE OUTER QUERY

SELECT * FROM TBL_EMPL_MASTER
SELECT SUM(SALARY)/COUNT(*) FROM TBL_EMPL_MASTER
--INTERVIEW QUESTION
--CAN U WRITE A QUERY, TO GET THE LIST OF EMPLOYEES WHOSE SALARY IS GREATER THAN AVERAGE SALARY OF ALL THE EMPLOYEES

SELECT * FROM TBL_EMPL_MASTER WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER)

--CAN U GET THE LIST OF STUDENTS WHO HAS NOT PAID THE FEES
SELECT * INTO TBL_STUDENTS FROM DB_MOHAN.DBO.TBL_STUDENTS
SELECT * INTO TBL_STUDENTS_FEES_DETAILS FROM DB_MOHAN.DBO.TBL_STUDENTS_FEES_DETAILS

SELECT * FROM TBL_STUDENTS WHERE STUDENTID NOT IN (SELECT STUDENTID FROM TBL_STUDENTS_FEES_DETAILS)

SELECT * FROM TBL_STUDENTS STD
LEFT JOIN TBL_STUDENTS_FEES_DETAILS FEES ON STD.STUDENTID=FEES.STUDENTID
WHERE FEES.STUDENTID IS NULL


--CORELATED SUB QUERY
--IF YOUR INNER QUERY AND OUTER QUERY ARE RELATED WITH EACH OTHER, THEN THAT QUERY IS CALLED CO-RELATED SUB QUERY
--IN CASE OF CORELATED SUB QUERY, THE OUTER QUERY WILL EXECUTE FIRST AND THEN THE INNER QUERY

--INTERVIEW QUESTION
--CAN U GET ME THE LIST OF EMPLOYEES WHOSE SALARY IS GREATER THAN AVERAGE SALARY OF THEIR DEPARTMENT EMPLOYEES

SELECT DEPTID,AVG(SALARY) FROM TBL_EMPL_MASTER GROUP BY DEPTID
SELECT AVG(SALARY) FROM TBL_EMPL_MASTER GROUP BY DEPTID

SELECT * FROM TBL_EMPL_MASTER WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER GROUP BY DEPTID)

SELECT * FROM TBL_EMPL_MASTER WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER WHERE DEPTID=100 GROUP BY DEPTID)
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER WHERE DEPTID=200 GROUP BY DEPTID)
SELECT * FROM TBL_EMPL_MASTER WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER WHERE DEPTID=300 GROUP BY DEPTID)

SELECT * FROM TBL_EMPL_MASTER EMP 
WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER WHERE DEPTID=EMP.DEPTID GROUP BY DEPTID)

SELECT * FROM TBL_EMPL_MASTER EMP 
WHERE SALARY > (SELECT AVG(SALARY) FROM TBL_EMPL_MASTER WHERE DEPTID=EMP.DEPTID)



-- MERGE	:	 A MECHANISM TO COMPARE TWO TABLES AND IDENTIFY MATCHING & MISSING DATA.
--				 PERFORM DML OPERATIONS ON THE THIS MATCHING & MISSING DATA.

MERGE TBLINVENTORY			-- THIS IS THE TARGET TABLE FOR DML OPERATIONS
USING TBLORDERS				-- THIS IS CALLED COMPARASION TABLE [REFERENCE TABLE]
ON
TBLINVENTORY.ID = TBLORDERS.ID 
WHEN MATCHED THEN		UPDATE SET TBLINVENTORY.MEASURE = TBLINVENTORY.MEASURE + TBLORDERS.MEASURE
WHEN NOT MATCHED THEN	INSERT VALUES (TBLORDERS.ID, TBLORDERS.TITLETAG, TBLORDERS.MEASURE)
;
-- MERGE	=	JOIN  + DML

SELECT *, IIF(MEASURE = 100, 'GRADE A', 'GRADE B') AS GRADE FROM TBLINVENTORY		-- IF AND ONLY IF

SELECT *, CASE	WHEN MEASURE = 100 THEN  'GRADE A'				-- UNLIMITTED CONDITIONS
				WHEN MEASURE = 200 THEN  'GRADE B'
				WHEN MEASURE = 300 THEN  'GRADE C'
				ELSE 'NOT APPLICABLE'
		  END
		  AS GRADE FROM TBLINVENTORY




--MERGE STATEMENT
--INTERVIEW QUESTION
--HOW WE CAN DO THE INCREMENTAL LOAD IN SQL SERVER

CREATE TABLE TBL_EMPL_SOURCE (EMPID INT, EMPNAME VARCHAR(30), SALARY INT)
INSERT INTO TBL_EMPL_SOURCE VALUES (1,'KRISHNA',300000)
INSERT INTO TBL_EMPL_SOURCE VALUES (2,'VARUN',400000)
INSERT INTO TBL_EMPL_SOURCE VALUES (3,'SATHISH',500000)
INSERT INTO TBL_EMPL_SOURCE VALUES (4,'KUMAR',600000)


SELECT * INTO TBL_EMPL_TARGET FROM TBL_EMPL_SOURCE

SELECT * FROM TBL_EMPL_SOURCE 
SELECT * FROM TBL_EMPL_TARGET

INSERT INTO TBL_EMPL_SOURCE VALUES (5,'MOHAN',500000)
INSERT INTO TBL_EMPL_SOURCE VALUES (6,'RAVI',600000)
UPDATE TBL_EMPL_SOURCE SET SALARY=700000 WHERE EMPID=3
DELETE FROM TBL_EMPL_SOURCE WHERE EMPID=2

MERGE INTO TBL_EMPL_TARGET TRGT USING TBL_EMPL_SOURCE SRC ON SRC.EMPID=TRGT.EMPID
WHEN MATCHED THEN
UPDATE SET TRGT.EMPNAME=SRC.EMPNAME, TRGT.SALARY=SRC.SALARY
WHEN NOT MATCHED THEN
INSERT VALUES (SRC.EMPID,SRC.EMPNAME,SRC.SALARY)
WHEN NOT MATCHED BY SOURCE THEN
DELETE;

--SOFT DELETE
MERGE INTO TBL_EMPL_TARGET TRGT USING TBL_EMPL_SOURCE SRC ON SRC.EMPID=TRGT.EMPID
WHEN MATCHED THEN
UPDATE SET TRGT.EMPNAME=SRC.EMPNAME, TRGT.SALARY=SRC.SALARY
WHEN NOT MATCHED THEN
INSERT VALUES (SRC.EMPID,SRC.EMPNAME,SRC.SALARY)
WHEN NOT MATCHED BY SOURCE THEN
UPDATE SET ACTIVE=0;




/* 
PIVOT OPERATION
PIVOT IS A MECHANISM TO CONVERT UNIQUE COLUMN VALUES TO COLUMNS. 
EX: 'SALESYEAR' COLUMN VALUES ARE : 2014, 2015, 2016, 2017.   */

CREATE TABLE #SERVICESALES (SERVICETYPE VARCHAR(80), SALESYEAR INT, NOOFLEADS INT);
 
INSERT #SERVICESALES VALUES 	('SQL SEVER TRAINING', 2014, 1200),
	('SQL SEVER TRAINING', 2015, 1900),('SQL SEVER TRAINING', 2016, 2300);
INSERT #SERVICESALES VALUES	('SQL DBA TRAINING', 2014, 4000),
	('SQL DBA TRAINING', 2015, 5500), ('SQL DBA TRAINING', 2016, 5900);
INSERT #SERVICESALES VALUES	('MSBI TRAINING', 2014, 900),
	('MSBI TRAINING', 2015, 1800),   ('MSBI TRAINING', 2016, 2300)
INSERT #SERVICESALES VALUES	('POWER BI TRAINING',2016,150),('POWER BI TRAINING',2017,100);
INSERT #SERVICESALES VALUES	('CASE STUDIES N PROJECTS', 2015, 1000),
	('CASE STUDIES N PROJECTS', 2016, 2800),('CASE STUDIES N PROJECTS', 2017, 4000);

SELECT * FROM #SERVICESALES				-- DENORMALIZED

SELECT * FROM #SERVICESALES
PIVOT ( SUM(NOOFLEADS) FOR SALESYEAR IN ([2014])) AS PIVOTQUERY 

SELECT * FROM #SERVICESALES
PIVOT ( SUM(NOOFLEADS) FOR SALESYEAR IN ([2014], [2015])) AS PIVOTQUERY 

SELECT * FROM #SERVICESALES
PIVOT ( SUM(NOOFLEADS) FOR SALESYEAR IN ([2014], [2015], [2016])) AS PIVOTQUERY 

SELECT * FROM #SERVICESALES
PIVOT ( SUM(NOOFLEADS) FOR SALESYEAR IN ([2014], [2015], [2016], [2017])) AS PIVOTQUERY		-- NORMALIZED

SELECT  * FROM #SERVICESALES
PIVOT ( SUM(NOOFLEADS) FOR SALESYEAR IN ([2014], [2015], [2016], [2017])) AS PIVOTQUERY		-- NORMALIZED


-- SCALAR FUNCTIONS
-- TABLE VALUED FUNCTIONS  [INLINE, MULTILINE]
-- OPENJSON()
-- OPENROWSET()
-- PIVOT



--PIVOT AND UNPIVOT
--PIVOT MEANS CONVERTING THE ROW DATA INTO COLUMN DATA

SELECT * FROM DB_MOHAN.DBO.TBL_PHARMA_SALES
SELECT DISTINCT TABLET_NAME FROM DB_MOHAN.DBO.TBL_PHARMA_SALES

SELECT BRANCHNAME,[ANACIN],[CALPOL],[CROCIN],[MEFTAL P],[METACIN]
FROM 
(SELECT BRANCHNAME,TABLET_NAME,SALES_AMOUNT FROM DB_MOHAN.DBO.TBL_PHARMA_SALES) A
PIVOT(SUM(SALES_AMOUNT) FOR TABLET_NAME IN ([ANACIN],[CALPOL],[CROCIN],[MEFTAL P],[METACIN])) B

SELECT * FROM DB_MOHAN.DBO.TBL_PHARMA_SALES WHERE BRANCHNAME='KR.PURAM' AND TABLET_NAME='CALPOL'

SELECT * FROM DB_MOHAN.DBO.TBL_PHARMA_SALES

SELECT BRANCHNAME,[ANACIN],[CALPOL],[CROCIN],[MEFTAL P],[METACIN]
INTO TBL_PIVOT_OP
FROM 
(SELECT BRANCHNAME,TABLET_NAME,SALES_AMOUNT FROM DB_MOHAN.DBO.TBL_PHARMA_SALES) A
PIVOT(SUM(SALES_AMOUNT) FOR TABLET_NAME IN ([ANACIN],[CALPOL],[CROCIN],[MEFTAL P],[METACIN])) B


--UNPIVOT 
--CONVERTING THE COLUMN VALUES INTO ROW DATA IS CALLED AS UNPIVOT

SELECT * FROM TBL_PIVOT_OP

SELECT BRANCHNAME,TABLETNAME,SALESAMT
FROM
(SELECT * FROM TBL_PIVOT_OP) A
UNPIVOT( SALESAMT FOR TABLETNAME IN ([ANACIN],[CALPOL],[CROCIN],[MEFTAL P],[METACIN]))B

SELECT * FROM TBL_PIVOT_OP


-- ITEM 2:	EXAMPLES FOR EXPLICIT TRANSACTIONS  : USED FOR CONDITIONAL COMMITS.
BEGIN TRANSACTION T1
INSERT INTO RESERVATION1 VALUES ('AI103', 21, 'ECO')
INSERT INTO RESERVATION1 VALUES ('AI104', 22, 'ECO')
IF @@ERROR = 0		-- THIS "GLOBAL VARIABLE" (PREDEFINED VARIABLE) REPORTS ERROR NUMBER OF PREVIOUS STATEMENT
COMMIT				-- TO SAVE THE ABOVE TWO ROWS IN THE TABLE	[CTRL + S]
ELSE			
ROLLBACK			-- TO UNDO THE SAVE OF ABOVE TWO ROWS		[CTRL + Z]

-- ITEM #3: 	EXAMPLE FOR IMPLICIT TRANSACTIONS
SET IMPLICIT_TRANSACTIONS ON	-- TO ENABLE IMPLICIT TRANSACTIONS. START TRANSACTION AUTOMATICALLY	
INSERT INTO RESERVATION1 VALUES ('AI105', 21, 'ECO')
INSERT INTO RESERVATION1 VALUES ('AI106', 23, 'ECO')
IF @@ERROR = 0	
COMMIT
ELSE			
ROLLBACK

SET IMPLICIT_TRANSACTIONS OFF	-- TO DISABLE IMPLICIT TRANSACTIONS. THIS IS A SESSION LEVEL SETTING.


-- ITEM #4: OPEN TRANSACTIONS : TRANSACTIONS WHICH ARE STARTED BUT NOT COMMITTED NOR ROLLEDBACK.  
-- IMPACT OF OPEN TRANSACTIONS : QUERY BLOCKING. MEANS, THE QUERY FOR OTHER SESSIONS RUN FOREVER.
BEGIN TRANSACTION T1
INSERT INTO RESERVATION1 VALUES ('EMI5', 21, 'ECO')
INSERT INTO RESERVATION1 VALUES ('EMI6', 22, 'ECO')

/*
GO TO FILE > NEW > QUERY IN CURRENT CONNECTION > THEN PASTE BELOW QUERY : 
SELECT * FROM RESERVATION1			-- WE OBSERVE QUERY BLOCKING. MEANS, QUERY RUNS FOREVER.

-- SOLUTION TO AVOID QUERY BLOCKING : USE "LOCK HINTS"		:		NOLOCK   &	READPAST

SELECT * FROM RESERVATION1			-- QUERY BLOCKING. MEANS : THE QUERY RUNS FOREVER.

SELECT * FROM RESERVATION1 WITH (NOLOCK)		-- NO QUERY BLOCKING BUT DIRTY READS. UNCOMMITED READS
SELECT * FROM RESERVATION1 WITH (READPAST)		-- NO QUERY BLOCKING AND NO DIRTY READS. COMMITED READS  **

*/


-- HOW TO RESOLVE QUERY BLOCKING?
COMMIT 




--TRANSACTIONS
--TRANSACTIONS WILL MAKE SURE THAT EITHER ALL THE QUERIES PRESENT INSIDE IT WILL EXECUTE SUCCESSFULLY OR NONE OF THEM SHOULD EXECUTE

SELECT * FROM TBL_EMPL_MASTER
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY
SELECT * FROM TBL_EMPLS_BANK_DETAILS


UPDATE TBL_EMPL_MASTER SET SALARY=90000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (4,'12/20/2019','12/23/2019',3)
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES ('6A',25234324234,'MADIWALA','ICICI')

BEGIN TRANSACTION

UPDATE TBL_EMPL_MASTER SET SALARY=12000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (9,'12/20/2019','12/23/2019',3)
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES ('6A',25234324234,'MADIWALA','ICICI')

COMMIT TRANSACTION

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY WHERE EMPID=9
SELECT * FROM TBL_EMPLS_BANK_DETAILS

BEGIN TRANSACTION

UPDATE TBL_EMPL_MASTER SET SALARY=95000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (6,'12/20/2019','12/23/2019',3)
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (6,25234324234,'MADIWALA','ICICI')

COMMIT TRANSACTION

--ROLLBACK
BEGIN TRANSACTION

UPDATE TBL_EMPL_MASTER SET SALARY=100000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (7,'12/20/2019','12/23/2019',3)
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (7,25234324234,'MADIWALA','ICICI')

ROLLBACK

--NESTED TRANSACTIONS
--A TRANSACTION INSIDE ANOTHER TRANSACTION IS CALLED AS NESTED TRANSACTION

BEGIN TRAN PR

UPDATE TBL_EMPL_MASTER SET SALARY=120000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (8,'12/20/2019','12/23/2019',3)

BEGIN TRAN CH
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (8,25234324234,'MADIWALA','ICICI')
INSERT INTO TBL_EMPLS_ADDRESS VALUES ('5A','MOHAN','JP NAGAR','BANGALORE')
COMMIT TRAN CH

COMMIT TRAN PR

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY WHERE EMPID=8
SELECT * FROM TBL_EMPLS_BANK_DETAILS WHERE EMPID=8

--INTERVIEW QUESTION
--ONCE WE COMMIT A TRANSACTION THEN CAN WE ROLLBACK THE EFFECTED QUERIES.
--IF IT IS INDEPENDENT/INDIVIDUAL TRANSACTION WE CAN NOT ROLLBACK ONCE WE COMMIT, BUT 
---IF IT IS A  CHILD TRANSACTION PRESENT INSIDE THE PARENT TRANSACTION, 
----THEN WE CAN ROLLBACK THE COMMITTED CHILD TRANSACTIONS QUERIES BY ROLLBACKING THE PARENT TRANSACTION


BEGIN TRAN PR

UPDATE TBL_EMPL_MASTER SET SALARY=130000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (9,'12/20/2019','12/23/2019',3)

BEGIN TRAN CH
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (7,25234324234,'MADIWALA','ICICI')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (4,'MOHAN','JP NAGAR','BANGALORE')
COMMIT TRAN CH

ROLLBACK TRAN PR

SELECT * FROM TBL_EMPLS_BANK_DETAILS WHERE EMPID=7
SELECT * FROM TBL_EMPLS_ADDRESS WHERE EMPID=4

--CAN WE ROLLBACK THE CHILD TRANSACTION
BEGIN TRAN PR

UPDATE TBL_EMPL_MASTER SET SALARY=150000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (10,'12/20/2019','12/23/2019',3)

BEGIN TRAN CH
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (9,25234324234,'MADIWALA','ICICI')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (4,'MOHAN','JP NAGAR','BANGALORE')
ROLLBACK TRAN CH

COMMIT TRAN PR

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1
SELECT * FROM TBL_EMPLS_LEAVE_HISTORY WHERE EMPID=10
SELECT * FROM TBL_EMPLS_BANK_DETAILS WHERE EMPID=10
SELECT * FROM TBL_EMPLS_ADDRESS WHERE EMPID=4

BEGIN TRAN PR

UPDATE TBL_EMPL_MASTER SET SALARY=160000 WHERE EMPID=1
INSERT INTO TBL_EMPLS_LEAVE_HISTORY VALUES (11,'12/20/2019','12/23/2019',3)
SAVE TRAN S1

BEGIN TRAN CH
INSERT INTO TBL_EMPLS_BANK_DETAILS VALUES (10,25234324234,'MADIWALA','ICICI')
INSERT INTO TBL_EMPLS_ADDRESS VALUES (4,'KARTHIK','JAYA NAGAR','BANGALORE')
ROLLBACK TRAN S1

COMMIT TRAN PR

--ISOLATION LEVELS
--READ COMMITTED, READ UNCOMMITTED, REPEATABLE READ, SNAPSHOT, SERILAZABLE 

--READ COMMITTED
--THIS ISOLATION LEVEL WILL ALLOW TO READ ONLY THE COMMITTED RECORDS

--USER 1 WINDOW QUERIES
BEGIN TRAN

UPDATE TBL_EMPL_MASTER SET SALARY=120000 WHERE EMPID=1

--COMMIT TRAN

--USER 2 WINDOW QUERIES

--SET TRANSACTION ISOLATION LEVEL READ COMMITTED

SELECT * FROM TBL_EMPL_MASTER

--READ UNCOMMITTED
--THIS ISOLATION LEVEL WILL ALLOW TO READ UNCOMMITTED DATA ALSO
--USER 1
BEGIN TRAN

UPDATE TBL_EMPL_MASTER SET SALARY=140000 WHERE EMPID=1

--COMMIT TRAN
--USER 2

--SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

SELECT * FROM TBL_EMPL_MASTER

--REPEATABLE READ
--IN THIS ISOLATION LEVEL, WHEN A USER IS READING THE TABLE DATA, THE OTHER USERS ARE NOT ALLOWED TO UPDATE THE TABLE

--USER 1
--SET TRANSACTION ISOLATION LEVEL REPEATABLE READ

BEGIN TRAN
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1

--UPD
--INST
--DEL

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1

--COMMIT TRAN

--USER 2 QUERIES

UPDATE TBL_EMPL_MASTER SET SALARY=190000 WHERE EMPID=1

SELECT * FROM TBL_EMPL_MASTER

--SNAPSHOT ISOLATION 

--USER 1 QUERIES
ALTER DATABASE [DB_UTPAL] SET ALLOW_SNAPSHOT_ISOLATION ON

SET TRANSACTION ISOLATION LEVEL SNAPSHOT

BEGIN TRAN
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1

--UPD
--INST
--DELTE

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1

--COMMIT TRAN

SELECT * FROM TBL_EMPL_MASTER WHERE EMPID=1

--USER 2 QUERIES

UPDATE TBL_EMPL_MASTER SET SALARY=250000 WHERE EMPID=1

--SERILIZABLE

--LOCKS
--SHARED LOCK, EXCLUSIVE LOCK, UPDATE LOCK

--SHARED LOCK
--SHARED LOCK CAN BE APPLIED WHEN WE ARE READING THE TABLE DATA, WHEN A SHARED LOCK IS THERE, THEN NO OTHER USER 
--IS ALLOWED TO UPDATE THE TABLE DATA , BUT OTHER USERS CAN READ THE TABLE DATA 
--MEANS MULTIPLE SHARED LOCKS ARE ALLOWED ON A TABLE

--EXCLUSIVE LOCK
--WHEN A USER IS UPDATING THE TABLE DATA, THEN EXCLUSIVE LOCK WILL BE APPLIED ON THE TABLE,
--WHEN A EXCLUSIVE LOCK, NO OTHER USER CAN READ OR UPDATE THE TABLE DATA
--MEANS NO OTHER LOCKS ARE ALLOWED ON A TABLE, WHEN EXCLUSIVE IS PRESENT ON A TABLE

--UPDATE LOCK(MIX OF SHARED LOCK + EXCLV LOCK)
--WHEN A USER TRIES TO UPDATE THE TABLE DATA, THEN THE UPDATE LOCK WILL BEHAVE LIKE A SHARED LOCK
--AND ONCE IT FOUND THE EMPLOYEE DATA, THEN THE UPDATE LOCK WILL BE CONVERTED TO EXCLUSIVE LOCK.


--SHARED LOCK
BEGIN TRAN
SELECT * FROM TBL_EMPL_MASTER WITH (HOLDLOCK)

COMMIT TRAN
SELECT * FROM SYS.DM_TRAN_LOCKS
SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID=1845581613

--EXCLUSIVE LOCK
BEGIN TRAN
UPDATE TBL_EMPL_MASTER SET SALARY=85000 WHERE EMPID=1

--COMMIT TRAN

--UPDATE LOCK
BEGIN TRAN
--SELECT * FROM TBL_EMPL_MASTER WITH (UPDLOCK)
UPDATE TBL_EMPL_MASTER WITH (UPDLOCK) SET SALARY=90000 WHERE EMPID=1

--COMMIT TRAN

--LOCKS GRANUALARITY
--WE CAN APPLY THE LOCKS AT DATABASE LEVEL, TABLE LEVEL, PAGE LEVEL, ROW LEVEL, KEY LEVEL

SELECT * FROM TBL_EMPL_MASTER WITH (TABLOCK)
SELECT * FROM TBL_EMPL_MASTER WITH (PAGLOCK)
SELECT * FROM TBL_EMPL_MASTER WITH (ROWLOCK)

SELECT * FROM TBL_EMPL_MASTER WITH (NOLOCK)

--DEADLOCK

--USER 2
SET DEADLOCK_PRIORITY HIGH

BEGIN TRAN

UPDATE TBL_EMPLS_BANK_DETAILS SET BRANCH_NAME='JP NAGAR' WHERE EMPID=1

UPDATE TBL_EMPL_MASTER SET SALARY = 550000 WHERE EMPID IN (5,7,8,9,10,11)

--COMMIT TRAN

--USER 1

BEGIN TRAN

UPDATE TBL_EMPL_MASTER SET SALARY = 350000 WHERE EMPID IN (5,7,8,9,10,11)

UPDATE TBL_EMPLS_BANK_DETAILS SET BRANCH_NAME='MARUTHI NAGAR' WHERE EMPID=1

--COMMIT TRAN


DECLARE @EMAIL VARCHAR(100)
SET @EMAIL='MKMOHAN13@GOOGLE.COM'

SELECT CHARINDEX('@',@EMAIL)
SELECT CHARINDEX('.',@EMAIL)

SELECT SUBSTRING(@EMAIL,10+1,(17-1)-10)

-- EXAMPLE FOR PROCEDURES:	USED FOR DYNAMIC QUERY STORE
CREATE PROCEDURE USP_REPORT_EMPLOYEES @COUNTRY	VARCHAR(30)   	-- @COUNTRY IS A PARAMETER. MEANS, INPUT VALUE 
AS 
SELECT * FROM SCHEMA1.EMPLOYEE_TABLE WHERE EMP_CNTRY = @COUNTRY

-- EXAMPLE FOR FUNCTION:	USED FOR DYNAMIC QUERY STORE
CREATE FUNCTION UDF_REPORT_EMPLOYEES (@COUNTRY	VARCHAR(30))   	-- @COUNTRY IS A PARAMETER. MEANS, INPUT VALUE 
RETURNS TABLE		-- TABLE IS A DATA TYPE
AS 
RETURN ( SELECT * FROM SCHEMA1.EMPLOYEE_TABLE WHERE EMP_CNTRY = @COUNTRY )

-- DURING DB CREATION, SET OF SYSTEM VIEWS ARE AUTO CREATED.   METADATA  = SYSTEM PREDEFINED DATA FOR AUDITS.
SELECT * FROM SYS.DATABASES				-- TO REPORT LIST OF ALL DATABASES IN THE SERVER
SELECT * FROM SYS.SCHEMAS				-- TO REPORT LIST OF ALL SCHEMAS IN THE DATABASE
SELECT * FROM SYS.TABLES				-- TO REPORT LIST OF ALL USER DEFINED TABLES IN THE DATABASE
SELECT * FROM SYS.COLUMNS				-- TO REPORT LIST OF ALL COLUMNS FROM ALL TABLES, VIEWS IN THE DATABASE
SELECT * FROM SYS.FOREIGN_KEYS			-- TO REPORT LIST OF ALL FOREIGN_KEYS FROM USER TABLES IN THE DATABASE
SELECT * FROM SYS.CHECK_CONSTRAINTS		-- TO REPORT LIST OF ALL CHECK CONSTRAINTS FROM USER TABLES IN THE DATABASE
SELECT * FROM SYS.INDEXES				-- TO REPORT LIST OF ALL INDEXES IN THE DATABASE
SELECT * FROM SYS.OBJECTS				-- TO REPORT LIST OF ALL OBJECTS [USER & SYSTEM DEFINED] IN THE DATABASE
SELECT * FROM SYS.VIEWS					-- TO REPORT LIST OF ALL VIEWS IN THE DATABASE
SELECT * FROM SYS.PROCEDURES			-- TO REPORT LIST OF ALL PROCEDURES IN THE DATABASE
SELECT * FROM SYS.TRIGGERS 				-- TO AUDIT THE TRIGGERS IN A DATABASE:

-- IMPORTANT SYSTEM PROCEDURES : FOR METADATA [SYSTEM INFORMATION] AUDITS
EXEC SP_HELPDB									-- TO REPORT LIST OF ALL DATABASES IN THE SERVER
EXECUTE SP_HELPDB  'DB_OBJECTS'				-- TO REPORT METADATA OR PROPERTIES OF THE GIVEN DATABASE
EXECUTE SP_HELP								-- TO REPORT LIST OF ALL OBJECTS IN THE DATABASE 
EXEC SP_HELP	'EMP_INFO'  					-- TO REPORT DEFINITION OF THE GIVEN OBJECT [TABLE]
EXEC SP_HELPINDEX 'EMP_INFO'					-- TO REPORT ALL INDEXES OF THE GIVEN TABLE
EXEC SP_PKEYS	'EMP_INFO'						-- TO REPORT PRIMARY KEY INFORMATION OF THE GIVEN TABLE
EXEC SP_RECOMPILE	'USP_REPEMP'    			-- RECOMPILE (CONVERT) THE QUERY FROM SQL LANGUAGE TO MACHINE CODE
EXEC SP_HELPTEXT	'VW_CANADA'    				-- REPORT DEFINITION OF PROCEDURE / VIEW  / FUNCTION
EXEC SP_RENAME  'NEW_TABLE_NAME' , 'EMP_INFO'  	-- RENAME A TABLE OR DATABASE OBJECT
EXEC SP_HELPCONSTRAINT 'PRODUCTION.PRODUCT';

-- ANY DATABASE OBJECT THAT CAN BE CREATED WITH "ON" KEYWORD BEFORE THE TABLE NAME CAN BE DISABLED.
-- WHAT ARE THE DATABASE OBJECTS CAN BE BE DISABLED?

-- JOINS ARE A MECHANISM TO COMPARE & REPORT DATA.  THEY ARE NOT OBJECTS. 


EXEC SP_DEPENDS 'RESERVATION1'
-- CAUTION 1	:	 WHENEVER WE RENAME THE TABLE, THE DEPENDANT OBJECTS SHOULD ALSO BE MODIFIFED WITH NEW NAME
-- CAUTION 2	:	 WHENEVER WE DROP THE TABLE, THE DEPENDANT OBJECTS BECOME "ORPHAN"

-- REQUIREMENT:  HOW TO COPY DATA FROM RESERVATION1 TO RESERVATION2 IN A TRANSACTION ENVIRONMENT ? 

CREATE TYPE	USERDEFINEDTABLETYPE 
AS TABLE
( 	
CRAFT_CODE 		NVARCHAR(30),	
NO_OF_SEATS 	INT,	
CLASS 			NVARCHAR(30)
)

CREATE PROCEDURE USPCOPYDATA @TVP  USERDEFINEDTABLETYPE	READONLY		-- THIS IS CALLED TABLE VALUED PARAMETER
AS
BEGIN
	BEGIN TRY
	BEGIN TRANSACTION
	INSERT INTO RESERVATION22 SELECT * FROM @TVP
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
	ROLLBACK TRANSACTION
	END CATCH
END 

DECLARE @TABLE_VARIABLE USERDEFINEDTABLETYPE 
INSERT INTO @TABLE_VARIABLE SELECT * FROM RESERVATION11
EXECUTE USPCOPYDATA @TABLE_VARIABLE

-- OUTPUT PARAMETERS:	ALSO CALLED "OUT" PARAMETERS. 
-- SUCH PARAMETERS THAT RETURN ONE OR MORE VALUES FROM THE GIVEN STORED PROCEDURE.


ALTER PROC USPREPORTROWCOUNT1 (@SEATS INT, @RCOUNT INT OUT)		-- OUT IS THE DIRECTION OF PARAMETER
AS
BEGIN
	BEGIN TRY
	BEGIN TRANSACTION
	SELECT @RCOUNT = COUNT(*) FROM RESERVATION11 WHERE NO_OF_SEATS > @SEATS
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
	ROLLBACK TRANSACTION
	END CATCH
END

-- HOW TO EXECUTE ABOVE STORED PROCEDURE ?
DECLARE @VAR INT					
EXECUTE USPREPORTROWCOUNT1 1, @VAR OUT
SELECT 'THERE ARE ' + CAST (@VAR AS VARCHAR(20))  + ' RESERVATIONS IN THE TABLE'



--INSERT INTO [DB_ERROR_LOGGING]  
--             (
--             ERRORNUMBER 
--            ,ERRORDESCRIPTION 
--            ,ERRORPROCEDURE 
--            ,ERRORSTATE 
--            ,ERRORSEVERITY 
--            ,ERRORLINE 
--            ,ERRORTIME 
--           )
--           VALUES
--           (
--             ERROR_NUMBER()
--            ,ERROR_MESSAGE()
--            ,ERROR_PROCEDURE()
--            ,ERROR_STATE()
--            ,ERROR_SEVERITY()
--            ,ERROR_LINE()
--            ,GETDATE()  
--           );

SELECT ERROR_MESSAGE()

/*
WHEN TO USE WHICH DATABASE OBJECTS?

	SCHEMAS						-		TO GROUP MULTIPLE OBJECTS [LIKE TABLES]

	TABLES						-		TO STORE DATA

	INDEXES						-		FOR FASTER SEARCH OPERATIONS

	CONSTRAINTS					-		FOR VALID DATA STORAGE

	VIEWS						-		TO STORE STATIC  SELECT QUERY.					ROW LEVEL SECURITY [RLS]

	FUNCTIONS					-		TO STORE DYNAMIC SELECT, DML QUERIES.			FLEXIBLE FOR REPORTING
	
	PROCEDURES					-		TO STORE DYNAMIC SELECT, DML, DDL QUERIES.		FASTER. PROGRAMMING

	TRIGGERS					-		TO STORE DYNAMIC SELECT, DML, DDL QUERIES.		AUTOMATED EXECUTIONS	
*/


-- IMPORTANT SYSTEM FUNCTIONS
SELECT GETDATE()			-- TO REPORT CURRENT DATE & TIME

SELECT DB_NAME()			-- TO REPORT CURRENTLY CONNECTED DATABASE NAME
SELECT DB_ID()				-- TO REPORT ID OF THE CURRENTLY CONNECTED DATABASE

SELECT OBJECT_ID('UDF_REPORT_EMPLOYEES')		-- TO REPORT ID OF THE GIVEN OBJECT
SELECT OBJECT_NAME(661577395)					-- TO REPORT NAME OF THE GIVEN OBJECT

SELECT SCHEMA_NAME()		-- TO REPORT CURRENT SCHEMA NAME (DEFAULT : DBO)

SELECT @@SERVERNAME			-- TO REPORT NAME OF THE CURRENTLY CONNECTED SERVER
SELECT @@VERSION			-- TO REPORT VERSION & EDITION OF THE CURRENTLY CONNECTED SERVER

--DYNAMIC SQL
--BUILDING THE QUERY DYNAMICALLY AT RUN TIME
--DECLARE @P_CITY VARCHAR(30)
--DECLARE @P_DEPT INT
--SET @P_CITY='SELECT ALL'
--SET @P_CITY='HYDERABAD'

--SET @P_DEPT='SELECT ALL'
--SET @P_DEPT=100

----SELECT * FROM TBL_EMPL_MASTER WHERE EMPCITY IN ('BANGALORE','CHENNAI','COCHIN','DELHI','HYDERABAD','MUMBAI','PUNE')
--SELECT * FROM TBL_EMPL_MASTER WHERE 1=1
--SELECT * FROM TBL_EMPL_MASTER WHERE EMPCITY='HYDERABAD'
--SELECT * FROM TBL_EMPL_MASTER WHERE DEPTID=100
--SELECT * FROM TBL_EMPL_MASTER WHERE EMPCITY='HYDERABAD' AND DEPTID=100

DECLARE @P_CITY VARCHAR(300)
DECLARE @P_DEPT VARCHAR(30)
--SET @P_CITY='SELECT ALL'
SET @P_CITY='BANGALORE,HYDERABAD,MUMBAI,CHENNAI'


--SET @P_DEPT='SELECT ALL'
SET @P_DEPT=200

DECLARE @SELECT_CLAUSE VARCHAR(MAX),@WHERE_CLAUSE VARCHAR(MAX)

SET @SELECT_CLAUSE ='SELECT * FROM TBL_EMPL_MASTER'
SET @WHERE_CLAUSE=' WHERE 1=1'

IF (@P_CITY != 'SELECT ALL')
BEGIN
--SET @WHERE_CLAUSE = @WHERE_CLAUSE + ' AND EMPCITY = '+''''+@P_CITY+''''
SET @WHERE_CLAUSE=@WHERE_CLAUSE + ' AND EMPCITY IN (SELECT * FROM DBO.UDF_SPLIT(' +''''+@P_CITY +''''+'))'
END

IF (@P_DEPT !='SELECT ALL')
BEGIN 
SET @WHERE_CLAUSE = @WHERE_CLAUSE + ' OR DEPTID =' +@P_DEPT
END 

--SELECT (@SELECT_CLAUSE + @WHERE_CLAUSE)
EXEC  (@SELECT_CLAUSE + @WHERE_CLAUSE)

--@P_CITY='BANGALORE,HYDERABAD,CHENNAI,MUMBAI'

ALTER FUNCTION UDF_SPLIT(@P_CITY VARCHAR(300))
RETURNS @CITYNAMES TABLE (EMPCITY VARCHAR(30))
AS
BEGIN

DECLARE @CITY_LIST VARCHAR(300),@COMMAS_CNT INT,@POSITION INT


SET @CITY_LIST=@P_CITY

SELECT @COMMAS_CNT =LEN(@CITY_LIST) -LEN(REPLACE(@CITY_LIST,',',''))--2

WHILE (@COMMAS_CNT>=0)
BEGIN
SELECT @POSITION=CHARINDEX(',',@CITY_LIST)

IF (@POSITION>0)GIN
INSERT INTO @CITYNAMES
SELECT SUBSTRING(@CITY_LIST,1,@POSITION-1)

SELECT @CITY_LIST=SUBSTRING(@CITY_LIST,@POSITION+1,1000)
END
ELSE
BEGIN
INSERT INTO @CITYNAMES
SELECT @CITY_LIST
END
SET @COMMAS_CNT=@COMMAS_CNT-1

END

RETURN 
END

--ERROR HANDLING
--ERROR HANDLING USING TRY CATCH BLOCK


CREATE TABLE TBL_EMPLS_PRIMARY (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), SALARY INT)

INSERT INTO TBL_EMPLS_PRIMARY VALUES (1,'KRISHNA',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (2,'MOHAN',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (1,'ABI',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (4,'SURESH',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (5,'RAJU',500000)

SELECT * FROM TBL_EMPLS_PRIMARY
--DELETE FROM TBL_EMPLS_PRIMARY

BEGIN TRY
INSERT INTO TBL_EMPLS_PRIMARY VALUES (1,'KRISHNA',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (2,'MOHAN',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (1,'ABI',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (4,'SURESH',500000)
INSERT INTO TBL_EMPLS_PRIMARY VALUES (5,'RAJU',500000)
END TRY

BEGIN CATCH
INSERT INTO TBL_ERROR_LOGS_HISTORY
SELECT ERROR_MESSAGE(), ERROR_LINE(),ERROR_NUMBER(),ERROR_PROCEDURE(),ERROR_SEVERITY()
END CATCH

SELECT * FROM SYS.MESSAGES WHERE MESSAGE_ID=2627
CREATE TABLE TBL_ERROR_LOGS_HISTORY (ERRORMSG VARCHAR(500),ERRORLINE INT,ERRORNUMBER INT,ERRORPROC VARCHAR(50),ERRORSEVERITY VARCHAR(10))
SELECT * FROM TBL_ERROR_LOGS_HISTORY

-- JAVA SCRIPT OBJECT NOTATION. USED BY WEB DEVELOPERS AND CLOUD ADMINS, FOR DATA TRANSFER

INSERT INTO  SHEEPCOUNTINGWORDS
SELECT  NUMBER, WORD 	
FROM 	OPENJSON	(	'[					
				{"NUMBER": 11,  "WORD": "YAN-A-DIK"}, 
				{"NUMBER": 12,  "WORD": "TAN-A-DIK"}, 
				{"NUMBER": 13,  "WORD": "TETHERA-DIK"}, 
				{"NUMBER": 14,  "WORD": "PETHERA-DIK"}, 
				{"NUMBER": 15,  "WORD": "BUMFIT"}, 
				{"NUMBER": 16,  "WORD": "YAN-A-BUMTIT"}, 
				{"NUMBER": 17,  "WORD": "TAN-A-BUMFIT"}, 
				{"NUMBER": 18,  "WORD": "TETHERA-BUMFIT"}, 
				{"NUMBER": 19,  "WORD": "PETHERA-BUMFIT"}, 
				{"NUMBER": 20,  "WORD": "FIGGOT"}
				]'
		) WITH (NUMBER INT '$.NUMBER', WORD VARCHAR(30) '$.WORD')

SELECT * FROM SHEEPCOUNTINGWORDS FOR XML AUTO	-- HORIZONTAL, TAG NAME = TABLE NAME. SINGLE TABLE
SELECT * FROM SHEEPCOUNTINGWORDS FOR XML PATH	-- VERTICAL, TAG NAME = "ROW". FOR WEB REPORTING
SELECT * FROM SHEEPCOUNTINGWORDS FOR XML RAW	-- HORIZONTAL, TAG NAME = "ROW". JOIN OF MULTIPLE TABLES

-- BLOB : BINARY LARGE OBJECT DATA
CREATE TABLE TBLSTORE
(
ID INT IDENTITY,
CONTENT VARBINARY(MAX)			-- THIS COLUMN CAN STORE UPTO 2 GB DATA PER VALUE. 
)

INSERT INTO TBLSTORE(CONTENT) 
SELECT BULKCOLUMN FROM OPENROWSET(BULK 'D:\w3schools.jpg', SINGLE_BLOB) AS SUBQUERY

SELECT * FROM TBLSTORE	-- WE USE CAST()  AND CONVERT()  TO REPORT DATA IN TEXT FORMAT. 

--HOW TO EXPORT THE DATA INTO XML FILES
--XML --EXTENDED MARKUP LANGUAGE
SELECT * FROM TBL_EMPLOYS_DATA FOR XML RAW
SELECT * FROM TBL_EMPLOYS_DATA FOR XML AUTO
SELECT * FROM TBL_EMPLOYS_DATA FOR XML PATH,ROOT('TBL_EMPLOYS_DATA')

--BACKUP AND RESTORE

BACKUP DATABASE DB_MOHAN
TO DISK='F:\DB_BACKUPS\DB_MOHAN.BKP'

RESTORE DATABASE DB_MOHAN
FROM DISK='F:\DB_BACKUPS\DB_MOHAN.BKP'

-- REQUIREMENT : HOW TO REPORT ONE ROW AT A TIME FROM ABOVE TABLE?
-- SOLUTION : CURSORS
-- CURSORS ARE VARIABLES USED TO ACCESS THE TABLE DATA ON A ROW BY ROW BASIS.
-- MEANS, WE CAN ACCESS ONLY ONE ROW AT A TIME.

-- EXAMPLE 1:
DECLARE CRS CURSOR
FOR
SELECT * FROM PRODUCTS_DATA
OPEN CRS 
FETCH NEXT FROM CRS 
FETCH NEXT FROM CRS 
FETCH NEXT FROM CRS 
FETCH NEXT FROM CRS 
CLOSE CRS 
DEALLOCATE CRS 

-- EXAMPLE 2:
DECLARE CRS CURSOR
STATIC				-- OPPOSITE : DYNAMIC 			
SCROLL				-- OPPOSITE : FORWARD_ONLY			
GLOBAL				-- OPPOSITE : LOCAL		
FOR
SELECT * FROM PRODUCTS_DATA
OPEN CRS 
FETCH FIRST FROM CRS 
FETCH ABSOLUTE 5 FROM CRS 
FETCH NEXT FROM CRS
FETCH NEXT FROM CRS
FETCH LAST FROM CRS 
FETCH PRIOR FROM CRS 
FETCH FIRST FROM CRS 
CLOSE CRS 
DEALLOCATE CRS 

-- REQUIREMENT :	REPORT LIST OF ALL TABLES AND NUMBER OF ROWS IN EACH TABLE IN THE DATABASE
SELECT * FROM SYS.TABLES 
SELECT COUNT(*) AS RCOUNT FROM TIME_DATA
SELECT TIME_DATA AS TABLENAME, COUNT(*) AS RCOUNT FROM TIME_DATA			-- ERROR
SELECT 'TIME_DATA' AS TABLENAME, COUNT(*) AS RCOUNT FROM TIME_DATA

-- FORMAT:
SELECT '??????' AS TABLENAME, COUNT(*) AS RCOUNT FROM ???????


-- SOLUTION V1:
DECLARE CRS CURSOR 
FOR
SELECT NAME FROM SYS.TABLES 
DECLARE @TNAME VARCHAR(30), @QUERY NVARCHAR(MAX)   --NVARCHAR : UNICODE DATA.  2GB SOACE
OPEN CRS 
FETCH NEXT FROM CRS INTO @TNAME			-- THIS IS TO FETCH 1ST TABLE NAME
WHILE @@FETCH_STATUS =  0				-- AS LONG AS CURSOR HAS MORE ROWS TO FETCH
	BEGIN
	SET @QUERY = 'SELECT '''+@TNAME+''' AS TABLENAME, COUNT(*) AS RCOUNT FROM ' + @TNAME
	EXEC SP_EXECUTESQL @QUERY
	FETCH NEXT FROM CRS INTO @TNAME	
	END 
DEALLOCATE CRS


-- SOLUTION V2:
CREATE PROC USP_REPORTDATA
AS
DECLARE CRS CURSOR 
FOR
SELECT NAME FROM SYS.TABLES 
DECLARE @TNAME VARCHAR(30), @QUERY NVARCHAR(MAX)   --NVARCHAR : UNICODE DATA.  2GB SOACE
OPEN CRS 
FETCH NEXT FROM CRS INTO @TNAME			-- THIS IS TO FETCH 1ST TABLE NAME
WHILE @@FETCH_STATUS =  0				-- AS LONG AS CURSOR HAS MORE ROWS TO FETCH
	BEGIN
	SET @QUERY = 'SELECT '''+@TNAME+''' AS TABLENAME, COUNT(*) AS RCOUNT FROM ' + @TNAME
	EXEC SP_EXECUTESQL @QUERY
	FETCH NEXT FROM CRS INTO @TNAME	
	END 
DEALLOCATE CRS

CREATE TABLE TBLREPORTRCOUNT (TNAME VARCHAR(30), RCOUNT BIGINT)
INSERT INTO TBLREPORTRCOUNT EXEC USP_REPORTDATA
SELECT * FROM TBLREPORTRCOUNT

--CURSORS
--HOW TO APPLY THE LOOPING CONCEPT USING CURSORS
--CURSORS WILL DO ROW BY ROW PROCESSING OF THE INPUT DATA WHICH WAS SUPPLIED TO IT.
DECLARE @DB_NAME VARCHAR(30),@FILEPATH VARCHAR(200)

DECLARE CR_DBBKP CURSOR FOR
SELECT NAME AS DBNAME FROM SYS.DATABASES WHERE DATABASE_ID<>2

OPEN CR_DBBKP
FETCH NEXT FROM CR_DBBKP INTO @DB_NAME
WHILE @@FETCH_STATUS=0
BEGIN
PRINT @DB_NAME 

SET @FILEPATH= 'F:\DB_BACKUPS\'+ @DB_NAME +'.BKP'
BACKUP DATABASE @DB_NAME
TO DISK=@FILEPATH

FETCH NEXT FROM CR_DBBKP INTO @DB_NAME
END
CLOSE CR_DBBKP
DEALLOCATE CR_DBBKP

--STORED PROCEDURE
--STORED PROCEDURE ARE USED TO STORE ANY TYPE OF QUERIES FOR RE-USABILITY PURPOSE
--STORED PROCEDURE CONTAINS COMPILED STATEMENT, IT WILL DO THE VALIDATION OF THE QUERIES(COMPILATION) ONLY AT THE TIME OF CREATION,
--IT WONT DO THE COMPILATION, WHEN EVER WE EXECUTE IT, SO THAT WE CAN SAVE THE COMPILATION TIME 
--STORED PROCEDURES REDUCE NETWORK TRAFFIC

CREATE PROCEDURE USP_EMP_DATA
AS
BEGIN
DROP TABLE IF EXISTS #TEMP_EMP

CREATE TABLE #TEMP_EMP (EMPID INT, EMPNAME VARCHAR(30),SALARY INT ,AGE INT,LEAVE_FROM DATE,LEAVE_UPTO DATE,
						DEPTID INT,PROJECT_NAME VARCHAR(30))

INSERT INTO #TEMP_EMP
SELECT		EMP.EMPID,EMP.EMPNAME,EMP.SALARY,EMP.AGE,LEV.LEAVE_FROM,
			LEV.LEAVE_UPTO,EMP.DEPTID,NULL AS PROJECT_NAME
FROM		TBL_EMPL_MASTER EMP 
LEFT JOIN   TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID

UPDATE #TEMP_EMP SET PROJECT_NAME=CASE WHEN DEPTID=100 THEN 'PROCUREMENT'
									   WHEN DEPTID=200 THEN 'ASD PROJECT'
									   WHEN DEPTID=300 THEN 'JKP PROJECT'
								  END 

SELECT T.*, BNK.ACCOUNT_NO,BNK.BRANCH_NAME,BNK.BANK_NAME
FROM #TEMP_EMP T LEFT JOIN TBL_EMPLS_BANK_DETAILS BNK ON T.EMPID=BNK.EMPID

DROP TABLE IF EXISTS #TEMP_EMP

END

--EXECUTION OF PROCEDURE
EXEC USP_EMP_DATA

SP_HELPTEXT USP_EMP_DATA

--TYPES OF STORED PROCEDURES

--PROCEDURE WITH OUT PARAMETERS
CREATE PROCEDURE USP_EMPLS_INFO 
AS
BEGIN
SELECT * FROM TBL_EMPL_MASTER
END

--EXECUTION
EXEC USP_EMPLS_INFO

--PROCEDURE WITH PARAMETERS
ALTER PROCEDURE USP_EMPLS_INFO_PARAMS (@EMPID INT,@EMPNAME VARCHAR(50))
AS
BEGIN
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID =@EMPID OR EMPNAME =@EMPNAME
END

--EXECUTION
EXEC USP_EMPLS_INFO_PARAMS 5,'SURESH'

--PROCEDURES WITH DEFAULT VALUE PARAMETERS
CREATE PROCEDURE USP_EMPLS_DEFAULT_PARAMS (@EMPID INT,@EMPNAME VARCHAR(50)='KRISHNA')
AS
BEGIN
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID =@EMPID OR EMPNAME =@EMPNAME
END

--EXECUTION
EXEC USP_EMPLS_DEFAULT_PARAMS 2,'SURESH'
EXEC USP_EMPLS_DEFAULT_PARAMS 2

CREATE PROCEDURE USP_EMPLS_DEFAULT1_PARAMS (@EMPID INT=5,@EMPNAME VARCHAR(50))
AS
BEGIN
SELECT * FROM TBL_EMPL_MASTER WHERE EMPID =@EMPID OR EMPNAME =@EMPNAME
END

--EXECUTION
EXEC USP_EMPLS_DEFAULT1_PARAMS @EMPNAME='SURESH'

ALTER PROCEDURE USP_EMPLS_DEFAULT2_PARAMS (@EMPID VARCHAR(30),@EMPNAME VARCHAR(50)='KRISHNA')
AS
BEGIN
SELECT * FROM TBL_EMPL_MASTER 
WHERE EMPID IN (SELECT * FROM DBO.UDF_SPLIT(@EMPID)) 
OR EMPNAME IN (SELECT * FROM DBO.UDF_SPLIT(@EMPNAME)) 
END

EXEC USP_EMPLS_DEFAULT2_PARAMS '1,2,3','SURESH,VARMA'

SELECT * FROM DBO.UDF_SPLIT('1,2,3')


--PROCEDURES WITH OUTPUT PARAMETER
CREATE PROCEDURE USP_EMPLS_OUTPUT_PARAMS (@EMPID INT,@EMPNAME VARCHAR(50) OUTPUT)
AS
BEGIN
SELECT @EMPNAME=EMPNAME FROM TBL_EMPL_MASTER WHERE EMPID =@EMPID
SELECT @EMPNAME AS EMPLOYEE_NAME
END

--EXECUTION
DECLARE @NAME VARCHAR(30)
EXEC USP_EMPLS_OUTPUT_PARAMS 500,@NAME OUTPUT

--PROCEDURE WITH RETURN VALUE
CREATE PROCEDURE USP_EMPLS_OUTPUT_RETURN_PARAMS (@EMPID INT,@EMPNAME VARCHAR(50) OUTPUT)
AS
BEGIN
SELECT @EMPNAME=EMPNAME FROM TBL_EMPL_MASTER WHERE EMPID =@EMPID
SELECT @EMPNAME AS EMPLOYEE_NAME

IF (@EMPNAME IS NOT NULL)
RETURN 1
ELSE
RETURN 0
END

--EXECUTION
DECLARE @ENAME VARCHAR(30),@RET INT
EXEC @RET=USP_EMPLS_OUTPUT_RETURN_PARAMS 500,@ENAME OUTPUT

SELECT @RET AS RETURN_VALUE

--NESTED PROCEDURES
--IF WE CALL A PROCEDURE INSIDE ANOTHER PROCEDURE

--CHILD PROCEDURE
CREATE PROCEDURE USP_EMPL_CHILD (@EMPNAME VARCHAR(30))
AS
BEGIN
SELECT EMPID,EMPNAME,SALARY,DESIGNATION,DATE_OF_JOIN
FROM TBL_EMPL_MASTER WHERE EMPNAME =@EMPNAME

END

--PARENT PROCEDURE
CREATE PROCEDURE USP_EMPL_PARENT (@P_ENAME VARCHAR(30))
AS
BEGIN
CREATE TABLE #EMP_TEMP (EMPID INT,ENAME VARCHAR(30),SALARY INT, DESG VARCHAR(30), DOJ DATE)

INSERT INTO #EMP_TEMP
EXEC USP_EMPL_CHILD @P_ENAME

SELECT T.*,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS 
FROM #EMP_TEMP T LEFT JOIN TBL_EMPLS_LEAVE_HISTORY LEV ON T.EMPID=LEV.EMPID
END

--EXECUTION
EXEC USP_EMPL_PARENT 'SURESH'


-- REQUIREMENT 1:  HOW TO COMPUTE SUM OF THREE NUMBERS ?
CREATE FUNCTION FNCOMPUTESUM (@INPUT1 INT, @INPUT2 INT, @INPUT3 INT)
RETURNS INT
AS
BEGIN
DECLARE	@SUM INT		-- THIS STATEMENT IS USED TO DEFINE A TEMPORARY VALUE STORE : VARIABLE
SET @SUM = @INPUT1 + @INPUT2 + @INPUT3
RETURN @SUM
END 

-- REQUIREMENT 2: HOW TO GENERATE A SEQUENCE OF VALUES BASED ON GIVEN START & END LIMITS?  MULTILINE TABLE VALUED FUNCTIONS
CREATE FUNCTION FNREPORTSEQUENCEVALUES (@START INT, @END INT)
RETURNS @TABLE_VAR  TABLE (SEQVALUE INT)	-- TABLE VARIABLES ARE STORED IN TEMPDB. 
AS
BEGIN
DECLARE @COUNTER INT = @START
WHILE @COUNTER <= @END							-- AS LONG AS; LOOP;
	BEGIN
	INSERT INTO @TABLE_VAR VALUES (@COUNTER)
	SET @COUNTER = @COUNTER + 1
	END 
RETURN 
END

-- HOW TO GENERATE SEQUENCE OF ALPHANUMERIC VALUES?   SQL1, SQL2, SQL3.....
ALTER FUNCTION FNREPORTSEQUENCEVALUES (@START INT, @END INT)
RETURNS @TABLE_VAR  TABLE (SEQVALUE VARCHAR(30))
AS
BEGIN
DECLARE @COUNTER INT = @START
WHILE @COUNTER <= @END
	BEGIN
	INSERT INTO @TABLE_VAR VALUES ('SQL' + CONVERT(VARCHAR(30), @COUNTER))
	SET @COUNTER = @COUNTER + 1
	END 
RETURN 
END


--USER DEFINED FUNCTIONS
--SCALAR FUNCTIONS, TABLE FUNCTIONS

--SCALAR FUNCTIONS
--THE FUNCTIONS WHICH RETURNS A SINGLE VALUE AS OUTPUT IS CALLED AS SCALAR FUNCTIONS

--TABLE FUNCTIONS
--THE FUNCTIONS WHICH RETURNS A TABLE AS AN OUTPUT

--SCALAR FUNCTION EXAMPLE
CREATE FUNCTION UDF_MONTHNAME(@MONTH_ID INT)
RETURNS VARCHAR(30)
AS
BEGIN
DECLARE @MONTH_NAME VARCHAR(30)
SELECT @MONTH_NAME=CASE WHEN @MONTH_ID=1 THEN 'JAN'
						WHEN @MONTH_ID=2 THEN 'FEB'
						WHEN @MONTH_ID=3 THEN 'MAR'
						WHEN @MONTH_ID=4 THEN 'APR'
						WHEN @MONTH_ID=5 THEN 'MAY'
						WHEN @MONTH_ID=6 THEN 'JUNE'
						WHEN @MONTH_ID=7 THEN 'JULY'
						WHEN @MONTH_ID=8 THEN 'AUG'
						WHEN @MONTH_ID=9 THEN 'SEP'
						WHEN @MONTH_ID=10 THEN 'OCT'
						WHEN @MONTH_ID=11 THEN 'NOV'
					ELSE 'DEC'
					END
RETURN @MONTH_NAME
END

--EXECUTION
SELECT MONTH(GETDATE())
SELECT EMPID,EMPNAME,DATE_OF_JOIN, DBO.UDF_MONTHNAME(MONTH(DATE_OF_JOIN)) AS DOJ_MONTHNAME FROM TBL_EMPL_MASTER
SELECT * FROM TBL_EMPL_MASTER WHERE DBO.UDF_MONTHNAME(MONTH(DATE_OF_JOIN))='JAN'

--TABLE FUNCTIONS
--THE FUNCTION WHICH IS GOING TO RETURN A TABLE AS AN OUTPUT THOSE FUNCTIONS ARE CALLED AS TABLE FUNCTIONS

--TWO TYPES OF TABLE FUNCTIONS
--INLINE TABLE, MULTIVALUE TABLE

--INLINE TABLE
ALTER FUNCTION UDF_EMPLS_INFO (@EMPID INT,@NAME VARCHAR(20))
RETURNS TABLE
AS
RETURN (SELECT		EMP.EMPID,EMP.EMPNAME,EMP.DESIGNATION,EMP.DATE_OF_JOIN,
					LEV.LEAVE_FROM,LEV.LEAVE_UPTO,LEV.NO_OF_DAYS,
					BNK.ACCOUNT_NO,BNK.BRANCH_NAME,BNK.BANK_NAME
		FROM		TBL_EMPL_MASTER EMP 
		LEFT JOIN	TBL_EMPLS_LEAVE_HISTORY LEV ON EMP.EMPID=LEV.EMPID
		LEFT JOIN	TBL_EMPLS_BANK_DETAILS BNK ON EMP.EMPID=BNK.EMPID
		WHERE EMP.EMPID=@EMPID OR EMP.EMPNAME=@NAME
		)

--EXECUTION
SELECT FN.*, ADR.ADDRESS1,ADR.CITY
FROM DBO.UDF_EMPLS_INFO(2,'SURESH') FN
LEFT JOIN TBL_EMPLS_ADDRESS ADR ON FN.EMPID=ADR.EMPID

--MULTIVALUE TABLE
CREATE FUNCTION UDF_MULTIVAL_EMPLS ()
RETURNS @EMPDATA TABLE (EMPID INT, EMPNAME VARCHAR(30), DOJ DATE,DESG VARCHAR(30))
AS
BEGIN
INSERT INTO @EMPDATA
SELECT EMPID,EMPNAME,DATE_OF_JOIN,DESIGNATION FROM TBL_EMPL_MASTER

RETURN

END

--EXECUTION
SELECT * FROM DBO.UDF_MULTIVAL_EMPLS()

--INTERVIEW QUESTION
--WHAT IS THE DIFFERENCE BETWEEN A STORED PROCEDURE AND A FUNCTION
--1.RETURN COMMAND IS MANDATORY INSIDE A FUNCTION,BUT RETURN COMMAND IS NOT MANDATORY INSIDE A STORED PROCEDURE
--2.WE CAN CALL A FUNCTION FROM INSIDE THE STORED PROCEDURE, BUT CALLING A PROCEDURE INSIDE THE FUNCTION IS NOT ALLOWED
--3.INSIDE THE PROCEDURE, WE CAN CREATE OR USE A TEMPORARY TABLES, BUT USAGE/CREATION OF TEMP TABLES IS NOT ALLOWED INSIDE A FUNCTION
--4. WE CAN CALL/EXECUTE A FUNCTION FROM THE "SELECT CLAUSE", "WHERE CLAUSE" AND FROM THE "FROM CLAUSE", BUT WE CAN NOT EXECUTE A PROCEDURE LIKE A FUNCTION

CREATE PROCEDURE USP_FUNC_CALL
AS
BEGIN
SELECT EMPID,EMPNAME,DATE_OF_JOIN, 
		DBO.UDF_MONTHNAME(MONTH(DATE_OF_JOIN)) AS DOJ_MONTHNAME 
FROM TBL_EMPL_MASTER

END

EXEC USP_FUNC_CALL

--CALLING A PROCEDURE INSIDE A FUNCTION
CREATE FUNCTION UDF_PROC_CALL()
RETURNS TABLE
AS
RETURN (EXEC USP_EMPLS_DEFAULT2_PARAMS '1,2,3','SURESH,VARMA')

--CREATING PROCEDURE WITH TEMP TABLE
CREATE PROCEDURE  USP_TEMP_SAMPLE
AS
BEGIN
DROP TABLE IF EXISTS #TEMP_EMP
CREATE TABLE #TEMP_EMP (EMPID INT,EMPNAME VARCHAR(30),SALARY INT)

INSERT INTO #TEMP_EMP VALUES (1,'MOHAN',4000000)

SELECT * FROM #TEMP_EMP

END

--EXECUTION
EXEC USP_TEMP_SAMPLE


--USING A TEMP TABLE INSIDE A FUNCTION
CREATE FUNCTION UDF_MULTIVAL_EMPLS2 ()
RETURNS #EMPDATA TABLE (EMPID INT, EMPNAME VARCHAR(30), DOJ DATE,DESG VARCHAR(30))
AS
BEGIN
INSERT INTO #EMPDATA
SELECT EMPID,EMPNAME,DATE_OF_JOIN,DESIGNATION FROM TBL_EMPL_MASTER

RETURN

END

-- REQ:   YOU NEED TO INSERT DATA INTO ABOVE TABLES TOGETHER.
CREATE VIEW VW_FLIGHT_RESERVATIONS
AS
SELECT 
R.CRAFT_CODE, R.NO_OF_SEATS, R.CLASS, 
F.SOURCE, F.DESTINATION 
FROM RESERVATIONS  AS R 
INNER JOIN 
FLIGHT  AS F 
ON R.CRAFT_CODE = F.CRAFT_CODE


SELECT * FROM VW_FLIGHT_RESERVATIONS

-- IN GENERAL, WHENEVER WE INSERT DATA INTO A VIEW IT GETS INSERTED INTO THE BASE TABLE.

-- BUT IF A VIEW IS BUILT ON MORE THAN ONE TABLE THEN INSERT STATEMENTS WILL NOT WORK DIRECTLY.
INSERT INTO VW_FLIGHT_RESERVATIONS VALUES ('EMI01', 11, 'ECO', 'CITY1', 'CITY2')  -- ERROR

-- SOLUTION: -- UPDATABLE VIEWS :   VIEWS DEFINED WITH TRIGGERS
CREATE TRIGGER TRIGDATAINSERT
ON VW_FLIGHT_RESERVATIONS
INSTEAD OF INSERT 
AS
BEGIN
	DECLARE @CRAFT_CODE VARCHAR(30), @NO_OF_SEATS VARCHAR(30), @CLASS VARCHAR(30),
		    @SOURCE VARCHAR(30), @DESTINATION VARCHAR(30)
	
	SELECT @CRAFT_CODE = CRAFT_CODE FROM INSERTED;
	SELECT @NO_OF_SEATS = NO_OF_SEATS FROM INSERTED;
	SELECT @CLASS = CLASS FROM INSERTED;
	SELECT @SOURCE = SOURCE FROM INSERTED;
	SELECT @DESTINATION = DESTINATION FROM INSERTED;
	 
	INSERT INTO FLIGHT			VALUES (@CRAFT_CODE, @SOURCE,  @DESTINATION)
	INSERT INTO RESERVATIONS	VALUES (@CRAFT_CODE, @NO_OF_SEATS, @CLASS)
END 


-- HOW TO ENSURE DYNAMIC DATA INSERTS?
-- SOLUTION : USING STORED PROCEDURES
CREATE PROCEDURE USP_INSERT_DATA 
@CRAFT_CODE VARCHAR(30), @NO_OF_SEATS VARCHAR(30), @CLASS VARCHAR(30), @SOURCE VARCHAR(30), @DESTINATION VARCHAR(30)
AS
	INSERT INTO VW_FLIGHT_RESERVATIONS VALUES (@CRAFT_CODE, @NO_OF_SEATS, @CLASS, @SOURCE, @DESTINATION)


-- PROCEDURE TO VIEW
	-- VIEW TO TRIGGER [UPDATABLE VIEW  =  VIEW DEFINED WITH A TRIGGER FOR DATA DISTRBUTION]
		-- TRIGGER TO BASE TABLES


-- STORED PROCEDURE TO VIEW			>>		VIEW TO TRIGGER				>>>	 TRIGGER TO ACTUAL TABLES. 



-- ALTERNATIVE TO ABOVE TRIGGER:
CREATE TRIGGER TRIGDATAINSERT
ON VW_FLIGHT_RESERVATIONS
INSTEAD OF INSERT 
AS
BEGIN
	BEGIN TRY
	BEGIN TRANSACTION
	DECLARE @CRAFT_CODE VARCHAR(30), @NO_OF_SEATS VARCHAR(30), @CLASS VARCHAR(30)
		    @SOURCE VARCHAR(30), @DESTINATION VARCHAR(30)
	
	SELECT @CRAFT_CODE = CRAFT_CODE FROM INSERTED;
	SELECT @NO_OF_SEATS = NO_OF_SEATS FROM INSERTED;
	SELECT @CLASS = CLASS FROM INSERTED;
	SELECT @SOURCE = SOURCE FROM INSERTED;
	SELECT @DESTINATION = DESTINATION FROM INSERTED;
	 
	INSERT INTO FLIGHT			VALUES (@CRAFT_CODE, @SOURCE,  @DESTINATION)
	INSERT INTO RESERVATIONS	VALUES (@CRAFT_CODE, @NO_OF_SEATS, @CLASS)
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
	ROLLBACK
	END CATCH
END 





--TRIGGERS
--TRIGGERS ARE USED MOSTLY FOR MAINTAINING THE HISTORICAL DATA OF A TABLE

--TWO TYPES OF TRIGGERS
--AFTER TRIGGER, INSTEAD OF TRIGGER

--SYSTEM TRIGGERS OR MAGIC TABLES
--INSERTED AND DELETED
--THE INSERTED TRIGGER WILL CAPTURE THE LATEST VALUES
--THE DELETED TRIGGER WILL CAPTURE THE PREVIOUS VALUES

CREATE TABLE TBL_EMPL_MSTR_HISTORY (EMPID INT, LATEST_SALARY INT,PREVIOUS_SALARY INT,USER_UPDATED VARCHAR(30),DATE_UPDATED DATE)
--AFTER TRIGGER

SELECT * FROM TBL_EMPL_MASTER

UPDATE TBL_EMPL_MASTER SET SALARY=100000 WHERE EMPID IN (3,4,5)

CREATE TRIGGER TR_EMPL_MSTR_UPD ON TBL_EMPL_MASTER
AFTER UPDATE
AS
BEGIN
INSERT INTO TBL_EMPL_MSTR_HISTORY
SELECT I.EMPID,I.SALARY AS LATEST_SAL_VALUE,D.SALARY AS PREV_SAL_VAL,SYSTEM_USER AS USER_UPD,GETDATE() AS UPD_DATE
FROM INSERTED I INNER JOIN DELETED D ON I.EMPID=D.EMPID

END

SELECT * FROM TBL_EMPL_MSTR_HISTORY

UPDATE TBL_EMPLS_LEAVE_HISTORY SET LEAVE_FROM='12/23/2020' WHERE EMPID=1

CREATE TRIGGER TR_LEV_DATA_UPD ON TBL_EMPLS_LEAVE_HISTORY
AFTER UPDATE--/ AFTER INSERT / AFTER DELETE
AS
BEGIN
SELECT * FROM INSERTED I 

END

SELECT * FROM INSERTED

BEGIN TRAN
UPDATE TBL_EMPL_MASTER SET SALARY=150000 WHERE EMPID IN (6)
ROLLBACK

--INSTEAD OF TRIGGERS
SELECT * FROM TBL_EMPL_LEAVE_DETAILS

DELETE FROM TBL_EMPL_LEAVE_DETAILS

CREATE TRIGGER TR_INSTD_DEL ON TBL_EMPL_LEAVE_DETAILS
INSTEAD OF DELETE--/UPDATE/INSERT
AS
BEGIN
PRINT 'HEY YOU DONT HAVE PERMISSION TO DELETE THE RECORDS FROM THIS TABLE'
END

--BOTH THE AFTER TRIGGERS AND INSTEAD OF TRIGGERS ARE APPLIED ON THE TABLES, AND THESE ARE CALLED AS DML TRIGGERS ALSO
--DATABASE TRIGGERS WHICH CAN BE APPLIED FOR DDL COMMANDS

ALTER TRIGGER TR_DROP_CMD ON DATABASE
FOR DROP_TABLE --/CREATE_TABLE/ALTER_TABLE
AS
BEGIN
ROLLBACK
PRINT 'HEY YOU DONT HAVE PERMISSION TO DROP ANY TABLE FROM THIS DATABASE'
END

DROP TABLE TBL_EMPLS_LEAVE_HISTORY

SELECT * FROM TBL_EMPLS_LEAVE_HISTORY

--DROP TRIGGERS 
DISABLE TRIGGER TR_LEV_DATA_UPD ON TBL_EMPLS_LEAVE_HISTORY

DROP TRIGGER TR_LEV_DATA_UPD 

DROP TRIGGER TR_DROP_CMD ON DATABASE

CREATE TABLE TBL_EMPLOY_MASTER_IND (EMPID INT, EMPNAME VARCHAR(30), EMPADDRESS NVARCHAR(100), 
								GENDER CHAR(1), AGE INT, MOBILE_NUMBER BIGINT, 
								DESIGNATION VARCHAR(20), DATE_OF_JOIN DATE, ACTIVE BIT)

CREATE TABLE TBL_EMPLOY_MASTER_IND2 (EMPID INT, EMPNAME VARCHAR(30), EMPADDRESS NVARCHAR(100), 
								GENDER CHAR(1), AGE INT, MOBILE_NUMBER BIGINT, 
								DESIGNATION VARCHAR(20), DATE_OF_JOIN DATE, ACTIVE BIT)

--INSERTING THE DATA INTO THE TABLE
INSERT INTO TBL_EMPLOY_MASTER_IND2 VALUES (10,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_IND2 VALUES (9,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_IND2 VALUES (8,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_IND2 VALUES (12,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_IND2 VALUES (11,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)



-- HOW TO ENABLE A TRIGGER?						-- ONLY DB ADMINS CAN PERFORM THIS OPERATIONS
ENABLE TRIGGER TRIGALTOP ON RESERVATION1




-- EXAMPLE FOR CLUSTERED INDEX
CREATE CLUSTERED INDEX INDX1	
ON STUDENTS (STD_ID ASC)
WITH
(
FILLFACTOR = 80,			-- EACH INDEX PAGE IS FILLED ONLY 80%. DEFAULT FILL FACTOR = 100%
PAD_INDEX = ON,				-- ABOVE FILL FACTOR IS APPLIED ON DATA PAGES ALSO
ONLINE = ON					-- ONLINE INDEX. AVAILABLE FOR USE DURING THEIR CREATION ITSELF
)	
ON [PRIMARY]


-- EXAMPLE FOR NONCLUSTERED INDEXES
-- REGULAR NONCLUSTERED INDEX
CREATE NONCLUSTERED INDEX INDX2 ON	STUDENTS (STD_COURSE)

-- INCLUDED NONCLUSTERED INDEX  
CREATE NONCLUSTERED INDEX INDX3	ON	STUDENTS (STD_COURSE) INCLUDE (STD_ID, STD_NAME, STD_AGE)

-- COLUMNSTORE NONCLUSTERED INDEX  : 
CREATE NONCLUSTERED COLUMNSTORE  INDEX INDX4	ON	STUDENTS(STD_COURSE)

-- FILTERED INDEX 
CREATE NONCLUSTERED INDEX INDX5	ON STUDENTS(STD_COURSE) WHERE STD_COURSE ='COMPUTERS'

-- COVERING INDEX
SELECT STD_ID, STD_NAME, STD_AGE  FROM STUDENTS	WHERE STD_COURSE = 'COMPUTERS'   -- INDX3 IS COVERING INDEX
SELECT STD_COURSE  FROM STUDENTS	WHERE STD_COURSE = 'COMPUTERS'				 -- INDX2, INDX 4 IS COVERING INDEX


-- QUERY OPTIMIZER GIVES PRIORITY FOR COVERING INDEX. NEXT PRIORITY FOR CLUSTERED INDEX. THEN FOR NONCLUSTERED.

-- INDEXED VIEW :  QUERY  + ITS RESULT [DATA]
CREATE VIEW INDX_VW  WITH SCHEMABINDING AS		SELECT STD_ID, STD_NAME,STD_COURSE  FROM DBO.STUDENTS

GO

CREATE UNIQUE CLUSTERED INDEX MAT_INDEX ON INDX_VW(STD_ID)

-- SCHEMABINDING :  PROPERTY TO PREVENT STRUCTURAL CHANGES ON THE BASE TABLE & COLUMNS USED IN THE VIEW.
-- MEANS, WE CANNOT RENAME / DROP / ALTER STD_ID, STD_NAME,STD_COURSE COLUMNS FROM STUDENTS TABLE.

-- STATISTICS : ADDITIONAL OBJECTS USED TO STORE COLUMN ADDRESS
-- FOR EASY REFERENCE TO DATA PAGES.

-- STATISTICS OPERATE ON TABLE COLUMNS
-- AUTO CREATED IN RESPONSE TO INDEX CREATIONS & COLUMNS USAGE IN THE QUERY CONDITIONS.

-- THESE STATISTICS WILL BE USED BY QUERY OPTIMIZER TO ENSURE THE BEST QUERY EXECUTION.

SELECT * FROM SYS.STATS			-- TO REPORT LIST OF ALL STATISTCS FROM THE DATABASE.
SELECT * FROM SYS.INDEXES		-- TO REPORT LIST OF ALL INDEXES FROM THE DATABASE

-- GIVEN A TABLE, HOW TO REPORT LIST OF ALL INDEXES?
SELECT * FROM SYS.INDEXES WHERE OBJECT_NAME(OBJECT_ID) = 'STUDENTS'

-- GIVEN A TABLE, HOW TO REPORT LIST OF ALL STATISTICS?
SELECT * FROM SYS.STATS WHERE OBJECT_NAME(OBJECT_ID) = 'STUDENTS'

-- TO ENSURE OPTIMAL EXECUTION OF THE QUERIES:
UPDATE STATISTICS  STUDENTS

CREATE STATISTICS STATS1 ON SALES_DATA(SALESAMOUNT)

UPDATE STATISTICS SALES_DATA

-- TO REPORT LIST OF STATISTICS IN ENTIRE DATABASE : 
SELECT * FROM SYS.STATS

-- TO REPORT LIST OF STATISTICS IN A SPECIFIC TABLE: 
SELECT * FROM SYS.STATS WHERE OBJECT_ID = OBJECT_ID('SALES_DATA')


--INDEXES
--INDEXES ARE USED TO IMPROVE THE PERFORMANCE OF THE SQL QUERIES
--TWO TYPES OF INDEXES
--CLUSTERED AND NONCLUSTERED INDEXES
SELECT * FROM TBL_EMPLOY_MASTER_IND

SP_HELPINDEX TBL_EMPLOY_MASTER_IND

CREATE INDEX IND1 ON TBL_EMPLOY_MASTER_IND(EMPID)

DROP INDEX IND1 ON TBL_EMPLOY_MASTER_IND

--CLUSTERED INDEX
SELECT * FROM TBL_EMPLOY_MASTER_IND

CREATE CLUSTERED INDEX CLS_IND ON TBL_EMPLOY_MASTER_IND(EMPID)

CREATE UNIQUE CLUSTERED INDEX CLS_IND ON TBL_EMPLOY_MASTER_IND2(EMPID)

SELECT * FROM TBL_EMPLOY_MASTER_IND2
SP_HELPINDEX TBL_EMPLOY_MASTER_IND2


--MDF FILE AND LDF FILE
--MASTER DATABASE FILE IN WHICH IT STORES THE DATA WE ARE INSERTING
--LOG DATABASE FILE, IT STORES THE QUERY LIST(DML AND DDL QUERIES)
SELECT * FROM TBL_EMPLOY_MASTER_IND WHERE EMPID=7

CREATE TABLE TBL_EMPLOYS_DEPT (BRANCHID INT, EMPNAME VARCHAR(30), AGE INT, DESG VARCHAR(30))

INSERT INTO TBL_EMPLOYS_DEPT VALUES (100,'CHARAN',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (200,'KUMARI',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (300,'SURESH',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (400,'KUMAR',35,'TEAM LEAD')


INSERT INTO TBL_EMPLOYS_DEPT VALUES (100,'BALU',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (200,'ANITHA',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (300,'SURESH',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (400,'KUMAR',35,'TEAM LEAD')


INSERT INTO TBL_EMPLOYS_DEPT VALUES (100,'RAMU',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (200,'BRAMAR',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (300,'SURESH',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (400,'KUMAR',35,'TEAM LEAD')


INSERT INTO TBL_EMPLOYS_DEPT VALUES (100,'ABIRAM',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (200,'DILLI',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (300,'SURESH',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (400,'KUMAR',35,'TEAM LEAD')

INSERT INTO TBL_EMPLOYS_DEPT VALUES (100,'MOHAN',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (200,'CHANDRA',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (300,'SURESH',35,'TEAM LEAD')
INSERT INTO TBL_EMPLOYS_DEPT VALUES (400,'KUMAR',35,'TEAM LEAD')

SELECT * FROM TBL_EMPLOYS_DEPT

CREATE CLUSTERED INDEX CLS1 ON TBL_EMPLOYS_DEPT (BRANCHID)
CREATE CLUSTERED INDEX CLS2 ON TBL_EMPLOYS_DEPT (EMPNAME)
DROP INDEX CLS1 ON TBL_EMPLOYS_DEPT

CREATE CLUSTERED INDEX CLS3 ON TBL_EMPLOYS_DEPT (BRANCHID,EMPNAME)
SP_HELPINDEX TBL_EMPLOYS_DEPT
--NON CLUSTERED INDEX
--IT WILL CREATE INDEX PAGE FOR THE TABLE DATA, IN WHICH IT CONTAINS THE POINTERS TO THE ROW DATA

CREATE TABLE TBL_EMPLOY_MASTER_NCLS (EMPID INT, EMPNAME VARCHAR(30), EMPADDRESS NVARCHAR(100), 
								GENDER CHAR(1), AGE INT, MOBILE_NUMBER BIGINT, 
								DESIGNATION VARCHAR(20), DATE_OF_JOIN DATE, ACTIVE BIT)

--INSERTING THE DATA INTO THE TABLE
INSERT INTO TBL_EMPLOY_MASTER_NCLS VALUES (10,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_NCLS VALUES (9,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_NCLS VALUES (8,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_NCLS VALUES (12,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_NCLS VALUES (11,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)

CREATE NONCLUSTERED INDEX IND4 ON TBL_EMPLOY_MASTER_NCLS(EMPID)

SP_HELPINDEX TBL_EMPLOY_MASTER_NCLS

SELECT * FROM TBL_EMPLOY_MASTER_NCLS
SELECT * FROM TBL_EMPLOY_MASTER WHERE EMPID=3
SELECT * FROM TBL_EMPLOY_MASTER WHERE EMPID=950 ORDER BY EMPNAME,DESIGNATION

CREATE NONCLUSTERED INDEX IND5 ON TBL_EMPLOY_MASTER_NCLS(EMPNAME,DESIGNATION)

CREATE UNIQUE NONCLUSTERED INDEX IND6 ON TBL_EMPLOY_MASTER_NCLS(EMPID)


--COLUMN STORE INDEX
CREATE TABLE TBL_EMPLOY_MASTER_STORE (EMPID INT, EMPNAME VARCHAR(30), EMPADDRESS NVARCHAR(100), 
								GENDER CHAR(1), AGE INT, MOBILE_NUMBER BIGINT, 
								DESIGNATION VARCHAR(20), DATE_OF_JOIN DATE, ACTIVE BIT)

--INSERTING THE DATA INTO THE TABLE
INSERT INTO TBL_EMPLOY_MASTER_STORE VALUES (10,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_STORE VALUES (9,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_STORE VALUES (8,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_STORE VALUES (12,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)
INSERT INTO TBL_EMPLOY_MASTER_STORE VALUES (11,'KRISHNA','BANGALORE,K.R.PURAM','M',35,866868687687,'TECH LEAD','12/23/2017',1)

CREATE COLUMNSTORE INDEX IND3 ON TBL_EMPLOY_MASTER_STORE(EMPID)

CREATE CLUSTERED COLUMNSTORE INDEX IND4 ON TBL_EMPLOY_MASTER_STORE
SP_HELPINDEX TBL_EMPLOY_MASTER_STORE

/*
NORMAL FORMS ARE A MECHANISM TO IDENTIFY THE TABLES AND THEIR RELATIONS.
ARRANGE THE TABLES IN THE DATABASE IN SUCH A WAY WE SAVE SPACE.
MEANS, NORMAL FORMS ARE USED IN THE DATABASE DESIGN FOR EASY RELATION MANAGEMENT AND EASY DATA VALIDATIONS.

1 NF		:	ATOMIC VALUES. MEANS : EVERY COLUMN CAN HAVE ONLY SINGULAR VALUES. 
				EX :	YEAR, QUARTER, MONTH, DAY  COLUMNS IN THE TIME_DATA TABLE @ CASE STUDY 

2 NF		:	A TABLE SHOULD HAVE ATLEAST ONE UNIQUE COLUMN.
				FUNCTIONAL DEPENDANCY (FD) USING "CANDIDATE KEYS". 
				CANDIDATE KEYS ARE SUCH COLUMNS THAT ENFORCE UNIQUENESS. PK & UQ ARE CANDIDATE KEYS.
				EX	:	TBLCOURSES TABLE IN CONSTRAINTS CHAPTER HAS UNIQUE KEY

3 NF		:	TABLE SHOULD HAVE ATLEAST ONE FOREIGN KEY.
				MULTI VALUED DEPENDANCY (MVD). IMPLEMENTATION OF REFERENCES TO PK / UQ [CANDIDATE KEY].
				THIS RESULTS IN  1 TO MANY RELATIONSHIP.  1  : M  [EX:  1 COURSE HAS MULTIPLE STUDENTS]
				EX	:	TBLSTUDENTS,  TBLSTAFF IN CONSTRAINTS CHAPTER.

				IF FK HAS CANDIDATE KEY THEN IT IS 1 : 1 RELATION.  MEANS, FK DOES NOT ALLOW DUPLICATES.
				THEN EACH PARENT HAS ONLY ONE CHILD. 

BCNF		:	TABLE SHOULD BE IN 3NF. THERE CAN BE MORE THAN ONE FOREIGN KEY IN THE TABLE.
				EX	:	SALES_DATA TABLE IN THE CASE STUDY
						SALES_DATA REFERENCES PRODUCTS_DATA, TIME_DATA & CUSTOMERS_DATA TABLES

4 NF		:	TABLE SHOULD BE IN 3RD NORMAL FORM AND ALSO SHOULD HAVE "SELF REFERENCING KEYS". 
				MEANS: A TABLE RELEATED TO ITSELF. ONE COLUMN IN A TABLE HAS RELATION TO ANOTHER COLUMN IN THE SAME TABLE.
*/

--NORMALIZATION RULES
--THESE RULES WILL BE APPLIED WHEN WE ARE DESIGNING THE DATABASE TABLES, 
--THESE RULES ARE USED TO AVOID THE REDUNDANT DATA IN THE TABLES

--3 NORMALIZATION RULES
--1ST NORMAL FORM, 2ND NF, 3RD NF

--FIRST NORMAL FORM
--EVERY COLUMN DATA SHOULD BE ATOMIC
--NO REPEATING GROUPS

CREATE TABLE TBL_EMPLS_1NF (EMPID VARCHAR(50), EMPNAME VARCHAR(50), SALARY VARCHAR(50))
INSERT INTO TBL_EMLS_1NF VALUES ('1,2,3','MOHAN, SURESH, VARUN','200000,300000,400000')

CREATE TABLE TBL_EMPLS_1NFV (EMPID1 INT, EMPID2 INT, EMPID3 INT,
							EMPNAME1 VARCHAR(30),EMPNAME2 VARCHAR(20),EMPNAME3 VARCHAR(30),
							SALARY1 INT,SALARY2 INT,SALARY3 INT)

INSERT INTO TBL_EMPLS_1NFV VALUES(1,2,3,'MOHAN','SURESH','VARUN',200000,300000,400000)

--SECOND NORMAL FORM
--THE TABLE SHOULD BE FIRST NORMAL FORM
--NO REDUNDANT DATA
--IF POSSBILE RELATE THE TABLES USING PRIMARY KEY AND FOREIGN KEY CONSTRAINTS

CREATE TABLE TBL_EMPLS_2NF (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, DEPTID INT, DEPT_HEAD VARCHAR(30))
INSERT INTO TBL_EMPLS_2NF VALUES (1,'KRISHNA',300000,100,'SUMATHI')
INSERT INTO TBL_EMPLS_2NF VALUES (2,'RAVI',310000,200,'RAMESH')
INSERT INTO TBL_EMPLS_2NF VALUES (3,'ABI',300000,300,'VARUN')
INSERT INTO TBL_EMPLS_2NF VALUES (4,'A',200000,100,'SUMATHI')
INSERT INTO TBL_EMPLS_2NF VALUES (5,'B',500000,200,'RAMESH')
INSERT INTO TBL_EMPLS_2NF VALUES (6,'C',600000,300,'VARUN')
INSERT INTO TBL_EMPLS_2NF VALUES (7,'D',700000,100,'SUMATHI')
INSERT INTO TBL_EMPLS_2NF VALUES (8,'E',800000,200,'RAMESH')
INSERT INTO TBL_EMPLS_2NF VALUES (9,'F',400000,300,'VARUN')
INSERT INTO TBL_EMPLS_2NF VALUES (10,'G',200000,100,'SUMATHI')
INSERT INTO TBL_EMPLS_2NF VALUES (11,'H',700000,200,'RAMESH')
INSERT INTO TBL_EMPLS_2NF VALUES (12,'I',900000,300,'VARUN')

CREATE TABLE TBL_EMPLS_2NF (EMPID INT, EMPNAME VARCHAR(30), SALARY INT, DEPTID INT)
INSERT INTO TBL_EMPLS_2NF VALUES (1,'KRISHNA',300000,100)
INSERT INTO TBL_EMPLS_2NF VALUES (2,'RAVI',310000,200)
INSERT INTO TBL_EMPLS_2NF VALUES (3,'ABI',300000,300)
INSERT INTO TBL_EMPLS_2NF VALUES (4,'A',200000,100)
INSERT INTO TBL_EMPLS_2NF VALUES (5,'B',500000,200)
INSERT INTO TBL_EMPLS_2NF VALUES (6,'C',600000,300)
INSERT INTO TBL_EMPLS_2NF VALUES (7,'D',700000,100)
INSERT INTO TBL_EMPLS_2NF VALUES (8,'E',800000,200)
INSERT INTO TBL_EMPLS_2NF VALUES (9,'F',400000,300)
INSERT INTO TBL_EMPLS_2NF VALUES (10,'G',200000,100)
INSERT INTO TBL_EMPLS_2NF VALUES (11,'H',700000,200)
INSERT INTO TBL_EMPLS_2NF VALUES (12,'I',900000,300)

CREATE TABLE TBL_DEPT (DEPTID INT, DEPT_HEAD VARCHAR(30))
INSERT INTO TBL_DEPT VALUES (100,'SUMATHI')
INSERT INTO TBL_DEPT VALUES (200,'RAMESH')
INSERT INTO TBL_DEPT VALUES (300,'VARUN')

--3RD NORMAL FORM
--THE TABLE DESIGN SHOULD BE IN 1ST NORMAL FORM AND 2ND NORMAL FORM
--THE EVERY NON KEY COLUMN SHOULD BE FULLY DEPENDANT/DIRECTLY RELATED ON THE PRIMARY KEY COLUMN

CREATE TABLE TBL_EMPL_3NF (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), SALARY INT, DEPTID INT, ANNUAL_SALARY INT)
INSERT INTO TBL_EMPL_3NF VALUES (1,'KRISHNA',200000,300,2400000)
INSERT INTO TBL_EMPL_3NF VALUES (2,'RAM',300000,100,3600000)
INSERT INTO TBL_EMPL_3NF VALUES (3,'RAVI',400000,200,4800000)
INSERT INTO TBL_EMPL_3NF VALUES (4,'ABI',500000,200,6000000)

CREATE TABLE TBL_EMPL_3NF (EMPID INT PRIMARY KEY, EMPNAME VARCHAR(30), SALARY INT, DEPTID INT)
INSERT INTO TBL_EMPL_3NF VALUES (1,'KRISHNA',200000,300)
INSERT INTO TBL_EMPL_3NF VALUES (2,'RAM',300000,100)
INSERT INTO TBL_EMPL_3NF VALUES (3,'RAVI',400000,200)
INSERT INTO TBL_EMPL_3NF VALUES (4,'ABI',500000,200)

SELECT *,SALARY*12 AS ANNUAL_SALARY FROM TBL_EMPL_3NF

--LINK SERVERS 

--SERVER A LOGIN
SELECT * FROM [DESKTOP-7GERK1S\MSSQLSERVER01].[DB_RAVI].[DBO].TBL_UNIONALL_LIS
SELECT * FROM [LINK_SERVER_DB_RAVI].[DB_RAVI].DBO.TBL_UNIONALL_LIST

--================ TABLE PARTITIONS==========



SELECT * FROM SYS.PARTITIONS WHERE OBJECT_ID = OBJECT_ID('SALES_DATA') 

-- STEP 2:  IMPLEMENT PARTITION ON THE TABLE
 
-- STEP 3:  VERIFY THE NUMBER OF PARTITIONS IN A TABLE:
SELECT * FROM SYS.PARTITIONS WHERE OBJECT_ID = OBJECT_ID('SALES_DATA') 

-- STEP 4: CHECK THE USAGE OF PARTITIONS:
SELECT * FROM SALES_DATA WHERE SALESAMOUNT < 40			-- QO SCANS 1ST PARTITION

SELECT * FROM SALES_DATA WHERE SALESAMOUNT > 2000		-- QO SCANS 3RD PARTITION

-- POSSIBLE ISSUE	:	DML OPERATIONS ON THE TABLE NEEDS TO RE-ARRANGE THE TABLE DATA BASED ON PARTITIONS. SLOW DML PERFORMANCE.

-- CAUTION	:	USE PARTITIONS FOR OLD, HISTORICAL DATA  [COLD DATA]

-- STEP 5:	HOW TO COMPRESS A SPECIFIC PARTTIION:
-- COMPRESSION IS A MECHANISM TO IDENTIFY UNIQUE VALUES OF A COLUMN AND STORE SUCH VALUES ONLY ONCE. REFERNCE IN ROWS WHERE REQUIRED.

ALTER TABLE SALES_DATA 
REBUILD
PARTITION = 1
WITH
(
DATA_COMPRESSION = ROW				-- APPLICABLE IF MULTIPLE COLUMNS HAVE SIMILAR VALUE. EX:  GENDER &  MARITAL STATUS  HAVE SAME VALUE "M"
)

ALTER TABLE SALES_DATA 
REBUILD
PARTITION = 2
WITH
(
DATA_COMPRESSION = PAGE				-- APPLICABLE IF MULTIPLE ROWS HAVE SIMILAR VALUE. EX:  SAME PRODUCT SOLD TO SAME CUSTOMER WITH A DIFFERENT SALE ID	
)

SELECT * FROM SYS.PARTITIONS WHERE OBJECT_ID = OBJECT_ID('SALES_DATA') 



SELECT * INTO TESTTABLE FROM SYSMESSAGES	-- CREATES TABLE, INSERTS DATA

INSERT INTO TESTTABLE SELECT * FROM TESTTABLE

SELECT * FROM SYS.DM_EXEC_QUERY_STATS			-- DYNAMIC MANAGEMENT VIEW

SELECT * FROM SYS.DM_EXEC_SQL_TEXT(0X030009000A1B727A0EAE5A0199AB000001000000000000000000000000000000000000000000000000000000) -- DMF
-- DYNAMIC MANAGEMENT FUNCTION

SELECT  TOP 10 TEXT, TOTAL_WORKER_TIME / EXECUTION_COUNT AS AVG_EXEC_TIME, DBID	,DB_NAME(DBID)		-- TIME IN MILLI SECONDS
FROM SYS.DM_EXEC_QUERY_STATS
CROSS APPLY						-- THIS IS SIMILAR TO CROSS JOIN
SYS.DM_EXEC_SQL_TEXT (PLAN_HANDLE)
ORDER BY  AVG_EXEC_TIME DESC 


TO MEASURE THE FRAGMENATION, WE USE THIS DMF: 
	SELECT * FROM SYS.DM_DB_INDEX_PHYSICAL_STATS (NULL, NULL, NULL, NULL, NULL)

			PARAMETER 1:	DATABASE ID OR NULL MEANS ALL DATABASES
			PARAMETER 2:	OBJECT ID OR NULL MEANS ALL TABLES AND VIEWS
			PARAMETER 3:	INDEX ID OR NULL MEANS ALL INDEXES
			PARAMETER 4:	PARTITION ID OR NULL MEANS ALL PARTITIONS
			PARAMETER 5:	NULL MEANS SAMPLED DATA


	-- HOW TO REPORT THE LIST OF HEAVILY FRAGMENED INDEXES?
SELECT * FROM SYS.DM_DB_INDEX_PHYSICAL_STATS(NULL,NULL, NULL, NULL, NULL)
WHERE AVG_FRAGMENTATION_IN_PERCENT >= 70

IF AVG_FRAGEMENTATION IS ABOVE 30% THEN PERFORM INDEX REBUILD
IF AVG_FRAGEMENTATION IS BETWEEN 15 & 30% THEN PERFORM INDEX REORGANIZE


		REBUILD:	TO RECREATE THE INDEX ON THE TABLE
				ALTER INDEX INDEX_NAME ON TABLE_NAME REBUILD

		REORGANIZE:	TO RE ARRANGE THE FRAGMENTED INDEX PAGES
				ALTER INDEX INDEX_NAME ON TABLE_NAME REORGANIZE

		RECOMMENDATION:   ENSURE TIMELY REORGANIZATION OF ALL INDEXES IN ALL 			TABLES IN ALL DATABASES IN THE SEVER.  USE "DATABASE MAINTENANCE PLANS"


-- DATABASE MAINTENANCE PLANS: 
		LAUNCH SSMS > CONNECT TO SERVER > MANAGEMENT > MAINTEANCNE PLANS >
		RIGHT CLICK > NEW MAINTENANCE PLAN WIZARD > SELECT SINGLE SCHEDULE FOR 
		ALL TASKS > SELECT INDEX REORGANIZE AND UPDATE STATISTICS > SELECT ALL 				DATABASES > IGNORE DATABASE THAT ARE OFFLINE > COMPRESS LARGE OBJECTS 			>FRAGEMENTAION ABOVE 15%, USED IN LAST 7 DAYS > PAGE COUNT > 1000 > FINISH.

EXECUTION PLAN ANALYSIS

EXECUTION PLAN TYPES:	
	1. ESTIMATED EXECUTION PLAN	:	PLAN GENERATED BEFORE QUERY EXECUTION
	2. LIVE EXECUTION PLAN	:	PLAN GENERATED DURING QUERY EXECUTION
	3. ACTUAL EXECUTION PLAN	:	PLAN GENERATED AFTER QUERY EXECUTION

PURPOSE:	 USING EXECUTION PLANS, WE IDENTIFY MISSING INDEXES AND CREATE THEM. 				ALSO ANALYSE QUERY COSTS.


--PERFORMANCE TUNING
---1.FIRST OF ALL WE NEED TO UNDERSTAND THE QUERY LOGIC BEFORE STARTING THE TUNING OF THE QUERY
--2.FIRST EXECUTE THE QUERY AND NOTE DOWN THE NUMBER OF RECORDS RESULTED AND AFTER PERFORMANCE TUNING ALSO WE SHOULD MAKE SURE 
----THAT SAME NUMBER OF RECORDS ARE RESULTED IN THE OUTPUT
--3. FIRST SEE THE EXECUTION PLAN FOR THE QUERY, USING WHICH WE CAN IDENTIFY WHETHER THE INDEXES ARE PRESENT ON THE TABLES USED IN THE QUERY
-----IF NO INDEXES ARE PRESENT, THEN FIRST CREATE A CLUSTERED INDEX ON THOSE TABLES AND THEN CREATE NONCLUSTERED INDEXES ON THE COLUMNS USED IN SELECT CLAUSE, WHERE CLAUSE , GROUP BY CLAUSE AND IN THE ORDER BY CLUASE
---- AFTER CREATING THE INDEXES , IF PERFORMANCE IS IMPROVED THEN KEEP THOSE INDEXES OR ELSE REMOVE THE UNWANTED THE INDEXES.
--4.REFRESH STATISTICS INFORMATION OF THE TABLES PRESENT IN THE QUERY BEFORE TUNING THE QUERY.
--5.IN THE SELECT CLAUSE ALWASY DONT USE THE "*" , JUST SPECIFY WHICH EVER COLUMNS YOU REQUIRED IN THE PRESENT QUERY
--6. ALWAYS USE NOLOCK AFTER THE TABLE NAMES

SELECT 
	EMP.EMPID,
	EMP.EMPNAME,
	EMP.AGE,
	EMP.DESIGNATION,
	LEV.EMPID,
	LEV.LEAVE_FROM,
	LEV.LEAVE_UPTO,
	ACCOUNT_NO,BRANCH_NAME,
	BANK_NAME
FROM   TBL_EMPL_MASTER AS EMP (NOLOCK)
JOIN   TBL_EMPLS_LEAVE_HISTORY AS LEV (NOLOCK) ON EMP.EMPID=LEV.EMPID
JOIN   TBL_EMPLS_BANK_DETAILS AS BNK (NOLOCK) ON EMP.EMPID=BNK.EMPID

--GO TO THE EXECUTION PLAN AND CHECK WHICH TABLE IS TAKING MORE TIME
--AND ARRANGE THE TABLES IN A MANNER THAT THE MAIN TABLE IS REFERRENCED FIRST


SELECT 
	EMP.EMPID,
	EMP.EMPNAME,
	EMP.AGE,
	EMP.DESIGNATION,
	LEV.EMPID,
	LEV.LEAVE_FROM,
	LEV.LEAVE_UPTO,
	ACCOUNT_NO,BRANCH_NAME,
	BANK_NAME
FROM   TBL_EMPLS_LEAVE_HISTORY AS LEV (NOLOCK)
JOIN   TBL_EMPLS_BANK_DETAILS AS BNK (NOLOCK) ON BNK.EMPID=LEV.EMPID
JOIN   TBL_EMPL_MASTER AS EMP (NOLOCK) ON EMP.EMPID=BNK.EMPID

--4.TRY TO CREATE INDEXES ON TABLES INVOLVED IN THE POOR PERFORMANCE QUERIES 
--AND IF PERFORMANCE IS NOT REMOVED DONT USE THE INDEXES.

--5. CHECK IF ANY UNWANTED OR UNUSED INDEXES ARE PLACED ON THE TABLES
SELECT * INTO #TEMP FROM VW_EMPLS_INFO

SELECT EMP.EMPID,EMP.EMPNAME,EMP.AGE,EMP.DESIGNATION,
	   LEV.EMPID,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,
	   ACCOUNT_NO,BRANCH_NAME,BANK_NAME
FROM   TBL_EMPL_MASTER AS EMP (NOLOCK)
JOIN   TBL_EMPLS_LEAVE_HISTORY AS LEV (NOLOCK) ON EMP.EMPID=LEV.EMPID
JOIN   TBL_EMPLS_BANK_DETAILS AS BNK (NOLOCK) ON EMP.EMPID=BNK.EMPID
JOIN   VW_EMPLS_INFO VW_EMP ON VW_EMP.EMPID=BNK.EMPID

SP_HELPTEXT VW_EMPLS_INFO

SELECT EMP.EMPID,EMP.EMPNAME,EMP.AGE,EMP.DESIGNATION,
	   LEV.EMPID,LEV.LEAVE_FROM,LEV.LEAVE_UPTO,
	   ACCOUNT_NO,BRANCH_NAME,BANK_NAME
FROM   TBL_EMPL_MASTER AS EMP (NOLOCK)
JOIN   TBL_EMPLS_LEAVE_HISTORY AS LEV (NOLOCK) ON EMP.EMPID=LEV.EMPID
JOIN   TBL_EMPLS_BANK_DETAILS AS BNK (NOLOCK) ON EMP.EMPID=BNK.EMPID
JOIN   #TEMP VW_EMP ON VW_EMP.EMPID=BNK.EMPID


--6.TRY TO PUT THE VIEWS DATA IN TO TEMP TABLES BEFORE USING THEM IN THE MAIN QUERY
--7.TRY TO CONVERT THE SUB QUERIES INTO CORELATED SUB QUERIES

--8.TRY TO AVOID FUNCTIONS IN THE MAIN REPORT QUERY
--9.IF WE HAVE TO USE FUNCTIONS THEN TRY TO CREATE TABLE FUNCTIONS INSTEAD OF SCALAR FUNCTIONS
--10.TRY TO USE TEMP TABLES INSTEAD OF TABLE VARIABLES
--11.TRY TO CONVERT THE PARAMETER VALUES TO THE RESPECTIVE DATA TYPES OF EXISTING COLUMN INSTEAD OF
--CONVERTING THE EXISTING COLUMN DATA TYPES


DECLARE @DATE DATETIME
SET @DATE =GETDATE()
--SELECT @DATE						DATE		 DATETIME
SELECT * FROM TBL_EMPLOY_MASTER WHERE DATE_OF_JOIN =CONVERT(DATE,@DATE)--APPLY LIKE THIS
SELECT * FROM TBL_EMPLOY_MASTER WHERE CONVERT(DATETIME,DATE_OF_JOIN) =@DATE--BUT NOT LIKE THIS


--12.TRY TO AVOID CURSORS INSTEAD USE WHILE LOOP OR UPDATE STATEMENTS
--13.--2.ALTERNATIVES OF COUNT(*)
--SELECT COUNT (*) STATEMENT MAKES A FULL TABLE SCAN TO RETURN THE TABLES ROW COUNT, IT CAN TAKE MUCH TIME FOR THE LARGE TABLES
--INSTEAD USE
SELECT * INTO TBL_EMPLS_MASTER FROM TBL_EMPLOY_MASTER
SELECT COUNT(*) FROM TBL_EMPLOY_MASTER
SELECT COUNT(1) FROM TBL_EMPLS_MASTER--1 CRORE RECORD
SP_HELPINDEX TBL_EMPLS_MASTER

SELECT * FROM SYS.OBJECTS WHERE NAME='TBL_EMPLS_MASTER'
SELECT ROWS,* FROM SYSINDEXES WHERE ID = OBJECT_ID('TBL_EMPLS_MASTER') AND INDID<2
SELECT * FROM SYSINDEXES WHERE ID = OBJECT_ID('TBL_EMPLOYEE') AND INDID<2

--14.--7.TRY TO USE UNION ALL INSTEAD OF UNION, WHENEVER POSSIBLE.
--15.--8.WE SHOULD TRY TO CAREFULLY USE CONDITIONS IN WHERE CLAUSE.

SELECT ID, COL1, COL2 FROM TABLE WHERE COL2 <> 10;
--INSTEAD OF:
SELECT ID, COL1, COL2 FROM TABLE WHERE COL2 != 10;

WRITE THE QUERY AS
SELECT ID, COL1, COL2 FROM TABLE WHERE COL1 LIKE 'NAV%';
--INSTEAD OF:
SELECT ID, COL1, COL2 FROM TABLE WHERE SUBSTR(COL1,1,3) = 'NAV';

WRITE THE QUERY AS
SELECT COL1, COL2 FROM TABLE WHERE COL3 BETWEEN MAX (COL3) AND MIN (COL3)
--INSTEAD OF:
SELECT COL1, COL2 FROM TABLE WHERE COL3 >= MAX (COL3) AND COL3 <= MIN (COL3)

--
--16.TRY TO ADD SET NOCOUNT ON STATEMENT INTO YOUR STORED PROCEDURES AS 
--IT STOPS THE MESSAGE INDICATING THE NUMBER OF ROWS AFFECTED BY A SQL STATEMENT. IT ALSO REDUCES NETWORK TRAFFIC, 
--BECAUSE OUR CLIENT WILL NOT RECEIVE ANY MESSAGE INDICATING THE NUMBER OF ROWS AFFECTED BY A SQL STATEMENT.

SET NOCOUNT ON
SET NOCOUNT OFF
--SET STATISTICS IO OFF
SELECT * FROM TBL_EMPL_MASTER

--17.TRY TO USE TOP KEYWORD OR THE SET ROWCOUNT STATEMENT IN THE SELECT STATEMENTS, 
--IF WE NEED TO RETURN ONLY THE FIRST N ROWS. THIS CAN IMPROVE PERFORMANCE OF OUR QUERIES, 
--AS THE SMALLER RESULT SET WILL BE RETURNED. IT CAN ALSO REDUCE THE TRAFFIC BETWEEN THE SERVER AND THE CLIENTS.
SELECT * FROM TBL_EMPL_MASTER--1 LAKH
SELECT TOP 1 * FROM TBL_EMPL_MASTER

SELECT COUNT(*) FROM TBL_EMPL_MASTER
SELECT COUNT(3) FROM TBL_EMPL_MASTER WHERE EMPID IS NOT NULL

--18.IF YOU NEED TO DELETE ALL ROWS OF A TABLE, TRY TO USE TRUNCATE TABLE COMMAND INSTEAD OF DELETE COMMAND. 
--USING THE TRUNCATE TABLE IS A FASTER WAY TO DELETE ALL ROWS OF A TABLES,
-- BECAUSE IT REMOVES ALL ROWS FROM A TABLE WITHOUT LOGGING EACH ROW DELETE.
--18.REMOVE ANY UNNECESSARY JOINS FROM TABLES.

--19.IF THERE IS CURSOR USED IN QUERY, SEE IF THERE IS ANY OTHER WAY TO AVOID THE USAGE OF THIS 
--(EITHER BY SELECT � INTO OR INSERT � INTO, OR BY USING MULTIPLE UPDATE STATEMENTS ETC).
----TRY TO AVOID USING CURSORS WHENEVER POSSIBLE. AS SQL SERVER CURSORS CAN RESULT IN SOME PERFORMANCE DEGRADATION 
--AS COMPARED TO SELECT STATEMENTS. TRY TO USE CORRELATED SUB-QUERIES OR DERIVED TABLES FOR ROW-BY-ROW OPERATIONS ON TABLES.

--20.USE CHAR/VARCHAR COLUMNS DATA TYPE, 
--INSTEAD OF NCHAR/NVARCHAR DATA TYPE IF WE DO NOT NEED TO STORE UNICODE DATA. 
--THE CHAR/VARCHAR DATA VALUE USES ONLY ONE BYTE TO STORE ONE CHARACTER; WHEREAS THE NCHAR/NVARCHAR VALUE USES TWO BYTES TO 
--STORE ONE CHARACTER, SO THE CHAR/VARCHAR COLUMNS USE TWO TIMES LESS SPACE TO STORE DATA AS COMPARED TO NCHAR/NVARCHAR DATA COLUMNS.

--21.TRY TO USE STORED PROCEDURES INSTEAD OF HEAVY QUERIES AS THEY CAN REDUCE NETWORK TRAFFIC, 
--BECAUSE OUR CLIENT WILL SEND TO SERVER ONLY STORED PROCEDURE NAME (ALONG WITH SOME PARAMETERS) 
--INSTEAD OF HEAVY AND LENGTHY QUERIES TEXT.

--22.TRY TO DROP INDEXES THAT ARE NOT BEING USED. BECAUSE EACH INDEX TAKES UP DISK SPACE AND SLOW THE DML OPERATIONS, 
--WE SHOULD DROP INDEXES THAT ARE NOT USED. WE CAN USE INDEX WIZARD TO IDENTIFY INDEXES THAT ARE NOT BEING USED IN OUR SQL QUERIES.
DROP INDEX IND2 ON TBL_EMPL_MASTER
SP_HELPINDEX TBL_EMPL_MASTER
--23. WE SHOULD TRY TO CREATE INDEXES ON COLUMNS THAT HAVE INTEGER VALUES RATHER THAN CHARACTER VALUES. 
--BECAUSE THE INTEGER VALUES HAVE LESS SIZE THAN THE SIZE OF CHARACTERS VALUES, 
--SO WE CAN REDUCE THE NUMBER OF INDEX PAGES WHICH ARE BEING USED TO STORE THE INDEX KEYS. T
--HIS FINALLY REDUCES THE NUMBER OF READS REQUIRED TO READ THE INDEX AND ENHANCES THE OVERALL INDEX PERFORMANCE.


--24. IF WE NEED TO JOIN SEVERAL TABLES VERY FREQUENTLY, 
--THEN WE SHOULD CONSIDER CREATING INDEX ON THE JOINED COLUMNS WHICH CAN SIGNIFICANTLY IMPROVE PERFORMANCE OF THE QUERIES 
--AGAINST THE JOINED TABLES.

--25. TRY TO AVOID ANY OPERATIONS ON THE FIELDS, WHERE EVER POSSIBLE. 
--SOME OPERATIONS WILL PREVENT THE USE OF INDEX ON A FIELD EVEN IF IT EXISTS�FOR EXAMPLE, LTRIM(RTRIM(FIELDCOLUMNNAME)) 
--AS SUCH OPERATIONS WILL DEGRADE THE PERFORMANCE.
-- FOR EXAMPLE, INSTEAD OF USING THE CONDITION CAST(DATECOLUMN AS VARCHAR(20)) = @DATESTR, 
-- WE SHOULD TRY TO CONVERT @DATESTR TO AN EXPRESSION OF DATETIME TYPE AND THEN COMPARE IT TO DATECOLUMN VALUE.









