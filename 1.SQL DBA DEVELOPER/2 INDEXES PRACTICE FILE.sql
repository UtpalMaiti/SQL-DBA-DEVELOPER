CREATE DATABASE INDEXDATABASE11
GO
USE INDEXDATABASE11
GO

CREATE TABLE STUDENTS
(
STD_ID INT, 
STD_NAME VARCHAR(30), 
STD_AGE FLOAT, 
STD_COURSE VARCHAR(30)
)

INSERT STUDENTS VALUES	(1001, 'AMIN', 23.5,'COMPUTERS'),  (1002, 'SAM', 23.5,'CIVIL'), 
				 (1003, 'AMINI', 23.5,'CIVIL'),  (1004, 'JOHN', 23.5,'COMPUTERS'), 
				 (1005, 'JEFF', 23.5,'COMPUTERS')

SELECT * FROM   STUDENTS			


-- EXAMPLE FOR CLUSTERED INDEX
CREATE CLUSTERED INDEX INDX1	
ON STUDENTS (STD_ID ASC)						-- WHAT TO SORT?
WITH
(
SORT_IN_TEMPDB = ON	,		-- WHERE TO SORT?
FILLFACTOR	=    80,		-- EACH INDEX PAGE IS FULL UPTO 80% FOR THE INDEXED DATA. REMAINING SPACE IS FREE.
PAD_INDEX =      ON,		-- THE ABOVE FILL FACTOR IS APPLIED TO DATA PAGES ALSO
ONLINE = ON					-- ONLINE INDEX. AVAILABLE FOR USE DURING THEIR CREATION ITSELF.
)	
ON [PRIMARY]
	
	
-- EXAMPLE FOR NONCLUSTERED INDEXES
-- REGULAR NONCLUSTERED INDEX
CREATE NONCLUSTERED INDEX INDX2 ON	STUDENTS (STD_COURSE)

-- INCLUDED NONCLUSTERED INDEX  
CREATE NONCLUSTERED INDEX INDX3	ON	STUDENTS (STD_COURSE) INCLUDE (STD_ID, STD_NAME, STD_AGE)

-- COLUMNSTORE NONCLUSTERED INDEX  :	UNIQUE COLUMN VALUES ARE INDEXED
CREATE NONCLUSTERED COLUMNSTORE  INDEX INDX4	ON	STUDENTS(STD_COURSE)


-- HOW TO DROP AN INDEX?
DROP INDEX STUDENTS.INDX4

-- FILTERED INDEX					:	ONLY FEW ROWS IN THE TABLE ARE INDEXED
CREATE NONCLUSTERED INDEX INDX5	ON STUDENTS(STD_COURSE) WHERE STD_COURSE ='COMPUTERS'

-- COVERING INDEX					:	SUCH INDEX THAT CONTAINS ALL COLUMNS USED IN THE QUERY
SELECT STD_ID, STD_NAME, STD_AGE  FROM STUDENTS	WHERE STD_COURSE = 'COMPUTERS'				-- INDX3 IS COVERING INDEX
SELECT DISTINCT STD_COURSE  FROM STUDENTS	WHERE STD_COURSE = 'COMPUTERS'					-- INDX4 CAN BE THE COVERING INDEX

-- QUERY OPTIMIZER GIVES PRIORITY FOR COVERING INDEX. NEXT PRIORITY FOR CLUSTERED INDEX. THEN FOR NONCLUSTERED.


-- INDEXED VIEW :  QUERY  + ITS RESULT [DATA]
CREATE VIEW INDX_VW  WITH SCHEMABINDING AS		SELECT STD_ID, STD_NAME, STD_COURSE  FROM DBO.STUDENTS
CREATE UNIQUE CLUSTERED INDEX mat_index ON INDX_VW(STD_ID)

-- SCHEMABINDING :  A PROPERTY TO PREVENT STRUCTURAL CHANGES (ALTER) ON THE BASE TABLE & COLUMNS USED IN THE VIEW.
-- EXAMPLE:	WE CANNOT RENAME THE TABLE.  WE CANNOT CHANGE THE DATA TYPE OF THE COLUMNS USED IN THE VIEW





-- ASSUME A PRIMARY KEY ON STDID 
SELECT STD_ID, STD_NAME, STD_COURSE FROM   STUDENTS	
WHERE
STD_COURSE  = 'COMPUTERS' AND STDID > 1001
ORDER BY STDID


-- HOW TO FINETUNE ABOVE QUERY?
FILTERED INDEX ON STD_COURSE
FILTERED INDEX ON STDID
INCLUDE INDEX ON STDID, STDNAME, STD_COURSE				=	 covering index
LOCK HINTS												=	 nolock, readpast

--https://docs.microsoft.com/en-us/sql/t-sql/statements/create-index-transact-sql?view=sql-server-ver15



-- STATISTICS : ADDITIONAL OBJECTS USED TO STORE COLUMN ADDRESS
-- FOR EASY REFERENCE TO DATA PAGES.

-- STATISTICS OPERATE ON TABLE COLUMNS
-- AUTO CREATED IN RESPONSE TO INDEX CREATIONS & COLUMNS USAGE IN THE QUERY CONDITIONS.

-- THESE STATISTICS WILL BE USED BY QUERY OPTIMIZER TO ENSURE THE BEST QUERY EXECUTION.

SELECT * FROM SYS.STATS			-- TO REPORT LIST OF ALL STATISTCS FROM THE DATABASE.
SELECT * FROM SYS.INDEXES		-- TO REPORT LIST OF ALL INDEXES FROM THE DATABASE

-- GIVEN A TABLE, HOW TO REPORT LIST OF ALL INDEXES?
SELECT * FROM SYS.INDEXES WHERE OBJECT_NAME(OBJECT_ID) = 'STUDENTS'

-- GIVEN A TABLE, HOW TO REPORT LIST OF ALL STATISTICS?
SELECT * FROM SYS.STATS WHERE OBJECT_NAME(OBJECT_ID) = 'STUDENTS'

-- HOW TO CREATE NEW STATISTICS MANUALLY?
CREATE STATISTICS STATS1 ON STUDENTS(STD_ID)

-- TO ENSURE OPTIMAL EXECUTION OF THE QUERIES:
UPDATE STATISTICS  STUDENTS

-- NEXT	:	DATABASE MAINTENANCE PLANS


